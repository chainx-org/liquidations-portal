{
    "version": 3,
    "file": "dai.cjs.production.min.js",
    "sources": [
        "../../../node_modules/regenerator-runtime/runtime.js",
        "../src/eth/accounts/setup.js",
        "../src/eth/web3/ProviderType.js",
        "../src/eth/accounts/factories.js",
        "../src/utils/constants.js",
        "../src/eth/AccountsService.js",
        "../src/utils/tracksTransactions.js",
        "../src/eth/AllowanceService.ts",
        "../src/utils/CacheService.js",
        "../contracts/abis.ts",
        "../src/eth/DSProxyService.ts",
        "../contracts/tokens.js",
        "../contracts/contracts.js",
        "../contracts/networks.ts",
        "../src/eth/Currency.js",
        "../src/eth/tokens/Erc20Token.ts",
        "../src/eth/tokens/EtherToken.ts",
        "../src/eth/tokens/WethToken.ts",
        "../src/eth/tokens/PethToken.ts",
        "../src/eth/EthereumTokenService.js",
        "../src/utils/index.js",
        "../src/utils/events/helpers.js",
        "../src/utils/events/EventEmitter.js",
        "../src/utils/events/EventService.js",
        "../src/eth/GasService.js",
        "../src/eth/MulticallService.ts",
        "../src/eth/NonceService.js",
        "../src/utils/events/NullEventService.js",
        "../src/eth/SmartContractService.js",
        "../src/eth/smartContract/wrapContract.js",
        "../src/utils/TimerService.js",
        "../src/eth/TransactionState.js",
        "../src/eth/TransactionTransitions.js",
        "../src/eth/TransactionLifeCycle.js",
        "../src/eth/TransactionObject.js",
        "../src/eth/TransactionManager.js",
        "../src/utils/Web3ServiceList.js",
        "../src/eth/Web3Service.ts",
        "../src/eth/web3/ShimEthersSigner.js",
        "../src/config/index.js",
        "../src/config/DefaultServiceProvider.ts",
        "../src/config/ConfigFactory.js",
        "../src/Maker.ts",
        "../src/utils/conversion.js",
        "../src/QueryApi.js",
        "../src/index.ts"
    ],
    "sourcesContent": [
        "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n",
        "import ProviderType from '../web3/ProviderType';\nimport Web3ProviderEngine from 'web3-provider-engine/dist/es5';\nimport WebsocketSubprovider from 'web3-provider-engine/dist/es5/subproviders/websocket';\nimport RpcSource from 'web3-provider-engine/dist/es5/subproviders/rpc';\nimport SubscriptionSubprovider from 'web3-provider-engine/dist/es5/subproviders/subscriptions';\nimport ProviderSubprovider from 'web3-provider-engine/dist/es5/subproviders/provider';\n\nconst DEFAULT_POLLING_INTERVAL = 4000;\n\nexport async function setupEngine(settings) {\n  const { provider: providerSettings, pollingInterval } = settings.web3;\n\n  const engine = new Web3ProviderEngine({\n    pollingInterval: pollingInterval || DEFAULT_POLLING_INTERVAL\n  });\n  const result = { engine };\n\n  const getHttpProvider = () => {\n    const rpcUrl = getRpcUrl(providerSettings);\n    const subscriptionProvider = new SubscriptionSubprovider();\n    subscriptionProvider.on('data', (err, data) =>\n      engine.emit('data', err, data)\n    );\n    engine.addProvider(subscriptionProvider);\n    return new RpcSource({ rpcUrl });\n  };\n\n  const getWebsocketProvider = () => {\n    const rpcUrl = getRpcUrl(providerSettings);\n    const subscriptionProvider = new SubscriptionSubprovider();\n    subscriptionProvider.on('data', (err, data) =>\n      engine.emit('data', err, data)\n    );\n    engine.addProvider(subscriptionProvider);\n    return new WebsocketSubprovider({ rpcUrl });\n  };\n\n  const getInjectedProvider = () => {\n    if (!providerSettings.inject) {\n      throw new Error(\"'inject' must be supplied with ProviderType.INJECT\");\n    }\n    return new ProviderSubprovider(providerSettings.inject);\n  };\n\n  switch (providerSettings.type) {\n    case ProviderType.BROWSER:\n      result.provider = await getBrowserProvider();\n      break;\n    case ProviderType.WEBSOCKET:\n      result.provider = getWebsocketProvider();\n      break;\n    case ProviderType.HTTP:\n      result.provider = getHttpProvider();\n      break;\n    case ProviderType.INFURA:\n      result.provider =\n        providerSettings.protocol === 'wss'\n          ? getWebsocketProvider()\n          : getHttpProvider();\n      break;\n    case ProviderType.INJECT:\n      result.provider = getInjectedProvider();\n      break;\n    default:\n      throw new Error('provider type must be defined');\n  }\n  engine.addProvider(result.provider);\n  return result;\n}\n\nexport async function getBrowserProvider() {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'Cannot use ProviderType.BROWSER because window is undefined'\n    );\n  }\n\n  const wrap = provider => {\n    const subprovider = new ProviderSubprovider(provider);\n    subprovider.isWindowProvider = true;\n    return subprovider;\n  };\n\n  if (window.ethereum) {\n    await window.ethereum.enable();\n    return wrap(window.ethereum);\n  } else if (window.web3) {\n    return wrap(window.web3.currentProvider);\n  }\n}\n\nfunction getInfuraUrl(protocol = 'https', network, infuraProjectId) {\n  if (!infuraProjectId) {\n    throw new Error('Cannot use infura without a project ID');\n  }\n  let url = `${protocol}://${network}.infura.io`;\n  url += protocol === 'wss' ? '/ws' : '';\n  url += `/v3/${infuraProjectId}`;\n  return url;\n}\n\nfunction getRpcUrl(providerSettings) {\n  const { network, protocol, infuraProjectId, type, url } = providerSettings;\n  switch (type) {\n    case ProviderType.HTTP:\n      return url;\n    case ProviderType.WEBSOCKET:\n      return url;\n    case ProviderType.INFURA:\n      return getInfuraUrl(protocol, network, infuraProjectId);\n    default:\n      throw new Error('Invalid web3 provider type: ' + type);\n  }\n}\n",
        "export default {\n  INFURA: 'INFURA',\n  HTTP: 'HTTP',\n\n  WEBSOCKET: 'WEBSOCKET',\n  // a browser provider is one that comes from the browser, i.e. `window.web3`,\n  // or from MetaMask's new \"postMessage\" method of requesting a provider.\n  BROWSER: 'BROWSER',\n  // A provider constructed outside this library and injected as-is\n  INJECT: 'INJECT'\n};\n",
        "import Account from 'eth-lib/lib/account';\nimport Wallet from 'web3-provider-engine/dist/es5/subproviders/wallet';\nimport { getBrowserProvider } from './setup';\nimport assert from 'assert';\n\nexport function privateKeyAccountFactory({ key }) {\n  if (typeof key != 'string' || !key.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid private key format');\n  }\n\n  const [keyWithPreffix, keySansPrefix] = key.startsWith('0x')\n    ? [key, key.replace(/^0x/, '')]\n    : ['0x' + key, key];\n\n  const account = Account.fromPrivate(keyWithPreffix);\n\n  const keyBuffer = Buffer.from(keySansPrefix, 'hex');\n\n  const subprovider = new Wallet(\n    {\n      getAddressString: () => account.address.toLowerCase(),\n      getPrivateKey: () => keyBuffer\n    },\n    {}\n  );\n\n  return { subprovider, address: account.address };\n}\n\nasync function getAccountAddress(subprovider, { offset = 0, address } = {}) {\n  assert(!(offset && address), 'Cannot set both address and offset');\n\n  return new Promise((resolve, reject) =>\n    subprovider.handleRequest(\n      { method: 'eth_accounts', params: [], id: 1 },\n      null,\n      (err, val) => {\n        if (err) return reject(err);\n        if (address) {\n          const matchingAddress = val.find(\n            a => a.toLowerCase() === address.toLowerCase()\n          );\n          assert(matchingAddress, 'No matching address found in provider.');\n          resolve(matchingAddress.toLowerCase());\n        } else {\n          resolve(\n            typeof val[offset] === 'string'\n              ? val[offset].toLowerCase()\n              : val[offset]\n          );\n        }\n      }\n    )\n  );\n}\n\nexport async function providerAccountFactory({ offset, address }, provider) {\n  // we need to be able to swap out this account while leaving the original\n  // provider in place for other accounts, so the subprovider here has to be\n  // a different instance. using Proxy is a simple way to accomplish this.\n  const subprovider = new Proxy(provider, {});\n  return {\n    subprovider,\n    address: await getAccountAddress(subprovider, { offset, address })\n  };\n}\n\nexport async function browserProviderAccountFactory() {\n  const subprovider = await getBrowserProvider();\n  return { subprovider, address: await getAccountAddress(subprovider) };\n}\n",
        "import BigNumber from 'bignumber.js';\n\nexport const WEI = new BigNumber('1e18');\nexport const WAD = new BigNumber('1e18');\nexport const RAY = new BigNumber('1e27');\nexport const RAD = new BigNumber('1e45');\n\nexport const UINT256_MAX =\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\n\nexport const AccountType = {\n  PROVIDER: 'provider',\n  PRIVATE_KEY: 'privateKey',\n  BROWSER: 'browser'\n};\n",
        "import { PublicService } from '@makerdao/services-core';\n\nimport { map, omit, pick } from 'lodash/fp';\nimport invariant from 'invariant';\nimport {\n  privateKeyAccountFactory,\n  providerAccountFactory,\n  browserProviderAccountFactory\n} from './accounts/factories';\nimport { setupEngine } from './accounts/setup';\nimport { AccountType } from '../utils/constants';\nimport assert from 'assert';\nimport debug from 'debug';\nconst log = debug('dai:AccountsService');\n\nconst sanitizeAccount = pick(['name', 'type', 'address']);\n\nexport default class AccountsService extends PublicService {\n  constructor(name = 'accounts') {\n    super(name, ['event']);\n    this._accounts = {};\n    this._accountFactories = {\n      privateKey: privateKeyAccountFactory,\n      provider: providerAccountFactory,\n      browser: browserProviderAccountFactory\n    };\n  }\n\n  async initialize(settings = {}) {\n    this._settings = omit('web3', settings);\n\n    const result = await setupEngine(settings);\n    this._engine = result.engine;\n    this._provider = result.provider;\n  }\n\n  async connect() {\n    const accountNames = Object.keys(this._settings);\n    for (const name of accountNames) {\n      await this.addAccount(name, this._settings[name]);\n    }\n    if (accountNames.length === 0) {\n      await this.addAccount('default', { type: AccountType.PROVIDER });\n    }\n    this._engine.start();\n  }\n\n  getProvider() {\n    return this._engine;\n  }\n\n  addAccountType(type, factory) {\n    invariant(\n      !this._accountFactories[type],\n      `Account type \"${type}\" is already defined`\n    );\n    this._accountFactories[type] = factory;\n  }\n\n  async addAccount(name, options = {}) {\n    if (name && typeof name !== 'string') {\n      options = name;\n      name = null;\n    }\n    const { type, autoSwitch, ...otherSettings } = options;\n    invariant(this._engine, 'engine must be set up before adding an account');\n    if (name && this._accounts[name]) {\n      throw new Error('An account with this name already exists.');\n    }\n    const factory = this._accountFactories[type];\n    invariant(factory, `no factory for type \"${type}\"`);\n    const accountData = await factory(otherSettings, this._provider);\n\n    // TODO allow this to silently fail only in situations where it's expected,\n    // e.g. when connecting to a read-only provider\n    if (!accountData.address) {\n      log(`Not adding account \"${name}\" (no address found)`);\n      return;\n    }\n    accountData.address = accountData.address.toLowerCase();\n\n    if (this._getAccountWithAddress(accountData.address)) {\n      throw new Error('An account with this address already exists.');\n    }\n\n    if (!name) name = accountData.address;\n    const account = {\n      name,\n      type,\n      autoSwitch: autoSwitch || false,\n      ...accountData\n    };\n\n    this._accounts[name] = account;\n    if (!this._currentAccount || name === 'default') {\n      this.useAccount(name);\n    }\n    if (this.hasAccount()) {\n      this.get('event').emit('accounts/ADD', {\n        account: sanitizeAccount(account)\n      });\n    }\n\n    return account;\n  }\n\n  listAccounts() {\n    return map(sanitizeAccount, this._accounts);\n  }\n\n  useAccount(name) {\n    const account = this._accounts[name];\n    invariant(account, `No account found with name \"${name}\".`);\n\n    if (this._autoSwitchCheckHandle) clearInterval(this._autoSwitchCheckHandle);\n\n    if (account.type === AccountType.BROWSER) {\n      assert(\n        isAddressSelected(account.address),\n        'cannot use a browser account that is not currently selected'\n      );\n      // detect account change and automatically switch active account if\n      // autoSwitch flag set (useful if using a browser wallet like MetaMask)\n      // see: https://github.com/MetaMask/faq/blob/master/DEVELOPERS.md#ear-listening-for-selected-account-changes\n      if (account.autoSwitch) {\n        this._autoSwitchCheckHandle = setInterval(\n          this._autoSwitchCheckAccountChange(account.address),\n          500\n        );\n      }\n    }\n\n    if (this._currentAccount) {\n      this._engine.stop();\n      this._engine.removeProvider(this.currentWallet());\n    }\n\n    this._currentAccount = name;\n    // add the provider at index 0 so that it takes precedence over RpcSource\n    this._engine.addProvider(this.currentWallet(), 0);\n    this._engine.start();\n    if (this.hasAccount()) {\n      this.get('event').emit('accounts/CHANGE', {\n        account: this.currentAccount()\n      });\n    }\n  }\n\n  _autoSwitchCheckAccountChange(addr) {\n    return async () => {\n      const activeBrowserAddress = getSelectedAddress().toLowerCase();\n      if (activeBrowserAddress !== addr) {\n        if (!this._getAccountWithAddress(activeBrowserAddress)) {\n          await this.addAccount({\n            type: AccountType.BROWSER,\n            autoSwitch: true\n          });\n        }\n        this.useAccountWithAddress(activeBrowserAddress);\n      }\n    };\n  }\n\n  _getAccountWithAddress(addr) {\n    const accountObjects = Object.values(this._accounts);\n    return accountObjects.find(\n      e => e.address.toUpperCase() === addr.toUpperCase()\n    );\n  }\n\n  useAccountWithAddress(addr) {\n    const account = this._getAccountWithAddress(addr);\n    if (!account) throw new Error(`No account found with address ${addr}`);\n    this.useAccount(account.name);\n  }\n\n  hasAccount() {\n    return !!this._currentAccount;\n  }\n\n  hasNonProviderAccount() {\n    return (\n      this.hasAccount() && this.currentAccount().type != AccountType.PROVIDER\n    );\n  }\n\n  // we intentionally omit subprovider (implementation detail) and privateKey\n  // (sensitive info).\n  currentAccount() {\n    invariant(this.hasAccount(), 'No account is set up.');\n    return sanitizeAccount(this._accounts[this._currentAccount]);\n  }\n\n  currentAddress() {\n    invariant(this.hasAccount(), 'No account is set up.');\n    return this._accounts[this._currentAccount].address;\n  }\n\n  currentWallet() {\n    return this._accounts[this._currentAccount].subprovider;\n  }\n}\n\nfunction getSelectedAddress() {\n  return typeof window.ethereum !== 'undefined'\n    ? window.ethereum.selectedAddress\n    : window.web3.eth.defaultAccount;\n}\n\nfunction isAddressSelected(address) {\n  // if using browser/MetaMask, we must use the currently selected account;\n  // however, it can be blank the first time the user connects their account.\n  const selectedAddress = getSelectedAddress();\n  return !selectedAddress || selectedAddress.toLowerCase() === address;\n}\n",
        "import { times } from 'lodash';\n\n/*\n\nThe default export is a decorator definition.\n\nIf a function is decorated with `@tracksTransactions`, it should expect its last\nargument to be an object with a key named `promise`. It should pass that\n`promise` argument along as a key in the last argument to any non-constant\nfunction calls it makes to a smart contract (i.e. an instance returned from the\ngetContract method in SmartContractService), or any calls it makes to other\nfunctions that will eventually call such smart contract functions.\n\nThis allows TransactionManager to let users input a promise and attach lifecycle\ncallbacks to all transactions that were created in the course of executing that\npromise.\n\n@tracksTransactions is only necessary when the function is async. If the\nfunction returns a contract call and does not make any async calls before that,\nthen the async keyword can be removed, and it just needs to have an `options`\nargument that it passes to its contract call.\n\nIf you need to apply this to a function that has any arguments with default\nvalues, use `@tracksTransactionsWithOptions({ numArguments })` instead, where\n`numArguments` is the total number of arguments to the function, including the\nlast object which contains a key named `promise`.\n\n*/\n\nconst tracksTransactions = tracksTransactionsWithOptions({});\nexport default tracksTransactions;\n\nexport function tracksTransactionsWithOptions({ numArguments }) {\n  return (target, name, descriptor) => {\n    const original = descriptor.value;\n    const correctArgsLength = numArguments || original.length;\n    descriptor.value = function(...args) {\n      const last = args[args.length - 1];\n      let options;\n      if (\n        typeof last === 'object' &&\n        last !== null &&\n        last.constructor === Object\n      ) {\n        args = args.slice(0, args.length - 1);\n        options = last;\n      } else {\n        options = {};\n      }\n\n      const promise = (async () => {\n        // this \"no-op await\" is necessary for the inner reference to the\n        // outer promise to become valid.\n        await 0;\n\n        // if there's already a promise, reuse it instead of setting this one--\n        // this allows the function we're running to behave differently when\n        // it's called directly vs. by another function. e.g. lockWeth\n        if (!options.promise) options.promise = promise;\n\n        // pad the list of arguments with `undefined` to account for any missing\n        // ones with default values.\n        const newArgs = [\n          ...args,\n          ...times(correctArgsLength - 1 - args.length, () => undefined),\n          options\n        ];\n        return original.apply(this, newArgs);\n      })();\n      return promise;\n    };\n    return descriptor;\n  };\n}\n",
        "import { PrivateService } from '@makerdao/services-core';\nimport BigNumber from 'bignumber.js';\nimport { UINT256_MAX } from '../utils/constants';\nimport tracksTransactions from '../utils/tracksTransactions';\n\nconst maxAllowance = new BigNumber(UINT256_MAX).shiftedBy(-18);\n\nexport default class AllowanceService extends PrivateService {\n  _shouldMinimizeAllowance: boolean;\n\n  constructor(name = 'allowance') {\n    super(name, ['token', 'event']);\n    this._shouldMinimizeAllowance = false;\n  }\n\n  initialize(settings) {\n    if (settings && settings.useMinimizeAllowancePolicy) {\n      this._shouldMinimizeAllowance = true;\n    }\n  }\n\n  @tracksTransactions\n  async requireAllowance(\n    tokenSymbol,\n    receiverAddress,\n    { estimate = maxAllowance, promise }\n  ) {\n    const token = this.get('token').getToken(tokenSymbol);\n    const ownerAddress = this.get('token')\n      .get('web3')\n      .currentAddress();\n    const allowance = await token.allowance(ownerAddress, receiverAddress);\n\n    if (allowance.lt(maxAllowance.div(2)) && !this._shouldMinimizeAllowance) {\n      const tx = await token.approveUnlimited(receiverAddress, { promise });\n      this.get('event').emit('allowance/APPROVE', {\n        transaction: tx\n      });\n      return tx;\n    }\n\n    if (allowance.lt(estimate) && this._shouldMinimizeAllowance) {\n      const tx = await token.approve(receiverAddress, estimate, { promise });\n      this.get('event').emit('allowance/APPROVE', {\n        transaction: tx\n      });\n    }\n  }\n\n  @tracksTransactions\n  async removeAllowance(tokenSymbol, spenderAddress, { promise }) {\n    const token = this.get('token').getToken(tokenSymbol);\n    const allowance = await token.allowance(\n      this.get('token')\n        .get('web3')\n        .currentAddress(),\n      spenderAddress\n    );\n    if (parseInt(allowance) != 0) {\n      return token.approve(spenderAddress, '0', { promise });\n    }\n  }\n}\n",
        "import { LocalService } from '@makerdao/services-core';\n\nexport default class CacheService extends LocalService {\n  constructor(name = 'cache') {\n    super(name);\n  }\n\n  initialize(settings = {}) {\n    if (settings.storage) {\n      this._storage = settings.storage;\n    }\n  }\n\n  isEnabled() {\n    return !!this._storage;\n  }\n\n  has(key) {\n    return !!this._storage && key in this._storage;\n  }\n\n  fetch(key) {\n    return this._storage ? this._storage[key] : undefined;\n  }\n\n  store(key, value) {\n    if (this._storage) this._storage[key] = value;\n  }\n}\n",
        "import erc20 from './abis/ERC20.json';\n\nimport dsEthToken from './abis/WETH9.json';\nimport dsValue from './abis/DSValue.json';\nimport dsGuard from './abis/DSGuard.json';\nimport dsChief from './abis/DSChief.json';\nimport dsSpell from './abis/DSSpell.json';\nimport dsSpellBook from './abis/DSSpellBook.json';\nimport dsProxy from './abis/DSProxy.json';\nimport dsProxyFactory from './abis/DSProxyFactory.json';\n\nimport makerOtc from './abis/MatchingMarket.json';\nimport oasisProxy from './abis/ProxyCreationAndExecute.json';\nimport saiProxy from './abis/SaiProxyCreateAndExecute.json';\nimport proxyRegistry from './abis/ProxyRegistry.json';\n\n// import saiTop from './abis/SaiTop.json';\nimport tub from './abis/SaiTub.json';\n// import tap from './abis/SaiTap.json';\n// import vox from './abis/SaiVox.json';\n// import mom from './abis/SaiMom.json';\n// import pit from './abis/GemPit.json';\n\nimport multicall from './abis/Multicall.json';\n\nimport cageFree from './abis/CageFree.json';\n\nconst daiV1 = {\n  //   saiTop,\n  tub\n  //   tap,\n  //   vox,\n  //   mom,\n  //   pit\n};\n\nconst dappHub = {\n  dsValue,\n  dsEthToken,\n  dsGuard,\n  dsChief,\n  dsSpell,\n  dsSpellBook,\n  dsProxy\n};\n\nconst exchangesV1 = {\n  makerOtc\n};\n\nconst general = {\n  erc20\n};\n\nconst proxies = {\n  oasisProxy,\n  saiProxy,\n  dsProxyFactory,\n  proxyRegistry\n};\n\nexport default {\n  daiV1,\n  dappHub,\n  exchangesV1,\n  general,\n  proxies,\n  multicall,\n  cageFree\n};\n",
        "import tracksTransactions from '../utils/tracksTransactions';\nimport { PrivateService } from '@makerdao/services-core';\nimport abis from '../../contracts/abis';\nimport { Contract } from 'ethers';\n\nexport default class DSProxyService extends PrivateService {\n  _currentProxy;\n  _smartContractService;\n  _currentAddress;\n\n  constructor(name = 'proxy') {\n    super(name, ['web3']);\n  }\n\n  async authenticate() {\n    this._currentProxy = await this.getProxyAddress();\n  }\n\n  // workaround for a circular dependency:\n  // smartContract -> transactionManager -> proxy -> smartContract\n  setSmartContractService(service) {\n    this._smartContractService = service;\n  }\n\n  _proxyRegistry() {\n    return this._smartContractService.getContract('PROXY_REGISTRY');\n  }\n\n  _resetDefaults(newProxy) {\n    this._currentProxy = newProxy;\n    this._currentAddress = this.get('web3').currentAddress();\n  }\n\n  // this needs to be async so it can fetch the proxy address just-in-time after\n  // an account switch. if we don't want this to be async, we have to make\n  // maker.useAccount async and set up a hook so that this service can get the\n  // new proxy address as soon as the switch happens\n  async currentProxy() {\n    return this._currentAddress === this.get('web3').currentAddress()\n      ? this._currentProxy\n      : this.getProxyAddress();\n  }\n\n  @tracksTransactions\n  async ensureProxy({ promise }) {\n    const proxy = await this.currentProxy();\n    if (proxy) return proxy;\n\n    await this.build({ promise });\n    return this._currentProxy;\n  }\n\n  @tracksTransactions\n  async build({ promise }) {\n    const proxy = await this.currentProxy();\n    if (proxy) {\n      throw new Error('This account already has a proxy deployed at ' + proxy);\n    }\n    const txo = await this._proxyRegistry().build({ promise });\n    this._currentProxy = txo.receipt.logs[0].address;\n    return txo;\n  }\n\n  execute(contract, method, args, options, address) {\n    if (!address && typeof this._currentProxy !== 'string') {\n      throw new Error('No proxy found for current account');\n    }\n    const proxyAddress = address ? address : this._currentProxy;\n    const proxyContract = this.getUnwrappedProxyContract(proxyAddress);\n    const data = contract.interface.encodeFunctionData(method, args);\n\n    return proxyContract['execute(address,bytes)'](\n      contract.address,\n      data,\n      options\n    );\n  }\n\n  async getProxyAddress(providedAddress = false) {\n    const address = providedAddress\n      ? providedAddress\n      : this.get('web3').currentAddress();\n\n    let proxyAddress = await this._proxyRegistry().proxies(address);\n    if (proxyAddress === '0x0000000000000000000000000000000000000000') {\n      proxyAddress = null;\n    }\n\n    if (!providedAddress) this._resetDefaults(proxyAddress);\n    return proxyAddress;\n  }\n\n  async getOwner(address) {\n    const contract = this._getWrappedProxyContract(address);\n    return contract.owner();\n  }\n\n  async setOwner(newOwner, proxyAddress = this._currentProxy) {\n    const contract = this._getWrappedProxyContract(proxyAddress);\n    return contract.setOwner(newOwner);\n  }\n\n  _getWrappedProxyContract(address) {\n    return this._smartContractService.getContractByAddressAndAbi(\n      address,\n      abis.dappHub.dsProxy\n    );\n  }\n\n  getUnwrappedProxyContract(address) {\n    return new Contract(\n      address,\n      abis.dappHub.dsProxy,\n      this.get('web3').getEthersSigner()\n    );\n  }\n}\n",
        "export default {\n  MKR: 'MKR',\n  WETH: 'WETH',\n  PETH: 'PETH',\n  ETH: 'ETH'\n};\n",
        "export default {\n  SAI_PIP: 'SAI_PIP',\n  SAI_TUB: 'SAI_TUB',\n  MAKER_OTC: 'MAKER_OTC',\n  OASIS_PROXY: 'OASIS_PROXY',\n  SAI_PROXY: 'SAI_PROXY',\n  PROXY_REGISTRY: 'PROXY_REGISTRY',\n  DS_PROXY_FACTORY: 'DS_PROXY_FACTORY',\n  DS_PROXY: 'DS_PROXY',\n  MULTICALL: 'MULTICALL',\n  SAI_CAGEFREE: 'SAI_CAGEFREE'\n};\n",
        "import tokens from './tokens';\nimport contracts from './contracts';\nimport abis from './abis';\nimport kovanAddresses from './addresses/kovan.json';\nimport goerliAddresses from './addresses/goerli.json';\nimport mainnetAddresses from './addresses/mainnet.json';\nimport testnetAddresses from './addresses/testnet.json';\n\nconst addressMapping = {\n  mainnet: mainnetAddresses,\n  kovan: kovanAddresses,\n  goerli: goerliAddresses,\n  testnet: testnetAddresses\n};\n\nexport function contractAddressesInfo(addresses) {\n  return {\n    // Tokens\n    [tokens.SAI]: [\n      {\n        version: 1,\n        address: addresses.SAI,\n        abi: abis.general.erc20,\n        decimals: 18\n      }\n    ],\n    [tokens.WETH]: [\n      {\n        version: 1,\n        address: addresses.SAI_GEM,\n        abi: abis.dappHub.dsEthToken,\n        decimals: 18\n      }\n    ],\n    [tokens.PETH]: [\n      {\n        version: 1,\n        address: addresses.SAI_SKR,\n        abi: abis.general.erc20,\n        decimals: 18\n      }\n    ],\n    [tokens.MKR]: [\n      {\n        version: 1,\n        address:\n          addresses.GOV_OLD || '0x0000000000000000000000000000000000000001',\n        abi: abis.general.erc20,\n        decimals: 18\n      },\n      {\n        version: 2,\n        address: addresses.SAI_GOV,\n        abi: abis.general.erc20,\n        decimals: 18\n      }\n    ],\n\n    // SAI\n    [contracts.SAI_PIP]: [\n      { version: 1, address: addresses.SAI_PIP, abi: abis.dappHub.dsValue }\n    ],\n    [contracts.SAI_TUB]: [\n      { version: 1, address: addresses.SAI_TUB, abi: abis.daiV1.tub }\n    ],\n\n    // Exchanges\n    [contracts.MAKER_OTC]: [\n      {\n        version: 1,\n        address: addresses.MAKER_OTC,\n        abi: abis.exchangesV1.makerOtc\n      }\n    ],\n\n    // Multicall\n    [contracts.MULTICALL]: [\n      {\n        version: 1,\n        address: addresses.MULTICALL,\n        abi: abis.multicall\n      }\n    ],\n\n    // CageFree\n    [contracts.SAI_CAGEFREE]: [\n      {\n        version: 1,\n        address: addresses.SAI_CAGEFREE,\n        abi: abis.cageFree\n      }\n    ],\n\n    // Proxies\n    [contracts.SAI_PROXY]: [\n      {\n        version: 1,\n        address: addresses.SAI_PROXY,\n        abi: abis.proxies.saiProxy\n      }\n    ],\n    [contracts.OASIS_PROXY]: [\n      {\n        version: 1,\n        address: addresses.OASIS_PROXY,\n        abi: abis.proxies.oasisProxy\n      }\n    ],\n    [contracts.DS_PROXY_FACTORY]: [\n      {\n        version: 1,\n        address: addresses.DS_PROXY_FACTORY,\n        abi: abis.proxies.dsProxyFactory\n      }\n    ],\n    [contracts.DS_PROXY]: [\n      {\n        version: 1,\n        abi: abis.dappHub.dsProxy\n      }\n    ],\n    [contracts.PROXY_REGISTRY]: [\n      {\n        version: 1,\n        address: addresses.PROXY_REGISTRY,\n        abi: abis.proxies.proxyRegistry\n      }\n    ]\n  };\n}\n\nexport function contractInfo(network) {\n  const addresses = addressMapping[network];\n  return contractAddressesInfo(addresses);\n}\n\nexport const TESTNET_ID = 999;\n\nexport default [\n  { name: 'mainnet', networkId: 1, contracts: contractInfo('mainnet') },\n  { name: 'morden', networkId: 2 },\n  { name: 'ropsten', networkId: 3 },\n  { name: 'rinkeby', networkId: 4 },\n  { name: 'goerli', networkId: 5, contracts: contractInfo('goerli') },\n  { name: 'kovan', networkId: 42, contracts: contractInfo('kovan') },\n  { name: 'test', networkId: 1337, contracts: contractInfo('testnet') },\n  { name: 'test', networkId: TESTNET_ID, contracts: contractInfo('testnet') }\n];\n",
        "import tokens from '../../contracts/tokens';\nimport { values } from 'lodash';\nimport {\n  createCurrency,\n  createCurrencyRatio,\n  createGetCurrency\n} from '@makerdao/currency';\n\nexport const currencies = values(tokens).reduce(\n  (output, symbol) => {\n    output[symbol] = createCurrency(symbol);\n    return output;\n  },\n  {\n    USD: createCurrency('USD')\n  }\n);\n\nexport const getCurrency = createGetCurrency(currencies);\n\n// we export both the currencies object and the individual currencies because\n// the latter is convenient when you know what you want to use, and the former\n// is convenient when you are picking a currency based on a symbol from input\n\nexport const ETH = currencies.ETH;\nexport const MKR = currencies.MKR;\nexport const PETH = currencies.PETH;\nexport const WETH = currencies.WETH;\nexport const USD = currencies.USD;\n\nexport const USD_ETH = createCurrencyRatio(USD, ETH);\nexport const USD_MKR = createCurrencyRatio(USD, MKR);\nexport const USD_PETH = createCurrencyRatio(USD, PETH);\nexport const USD_WETH = createCurrencyRatio(USD, WETH);\n\nObject.assign(currencies, {\n  USD_ETH,\n  USD_MKR,\n  USD_PETH,\n  USD_WETH\n});\n",
        "import { ethers } from 'ethers';\nimport { currencies, getCurrency } from '../Currency';\nimport { UINT256_MAX } from '../../utils/constants';\n\nexport default class Erc20Token {\n  _contract;\n  _web3;\n  _decimals;\n  symbol;\n  _currency;\n\n  constructor(contract, web3Service, decimals = 18, symbol, currency?) {\n    this._contract = contract;\n    this._web3 = web3Service;\n    this._decimals = decimals;\n    this.symbol = symbol;\n    this._currency = currency || currencies[symbol];\n  }\n\n  async allowance(tokenOwner, spender) {\n    return this._valueFromContract(\n      await this._contract.allowance(tokenOwner, spender)\n    );\n  }\n\n  async balance() {\n    return this.balanceOf(this._web3.currentAddress());\n  }\n\n  async balanceOf(owner) {\n    return this._valueFromContract(await this._contract.balanceOf(owner));\n  }\n\n  async totalSupply() {\n    return this._valueFromContract(await this._contract.totalSupply());\n  }\n\n  address() {\n    return this._contract.address;\n  }\n\n  _valueForContract(value, unit = this._currency) {\n    return this._getCurrency(value, unit).toFixed(this._decimals);\n  }\n\n  _valueFromContract(value) {\n    return this._currency(value.toString(), -1 * this._decimals);\n  }\n\n  approve(spender, value, { unit = this._currency, ...options } = {}) {\n    return this._contract.approve(\n      spender,\n      this._valueForContract(value, unit),\n      {\n        metadata: {\n          action: {\n            name: 'approve',\n            spender,\n            allowance: this._getCurrency(value, unit),\n            allowing: value != '0'\n          }\n        },\n        ...options\n      }\n    );\n  }\n\n  approveUnlimited(spender, options = {}) {\n    if (!spender) spender = this._web3.currentAddress();\n    return this._contract.approve(spender, ethers.BigNumber.from(UINT256_MAX), {\n      metadata: {\n        action: {\n          name: 'approve',\n          spender,\n          allowance: Number.MAX_SAFE_INTEGER,\n          allowing: true,\n          unlimited: true\n        }\n      },\n      ...options\n    });\n  }\n\n  transfer(to, value, { unit = this._currency, promise = undefined } = {}) {\n    return this._contract.transfer(to, this._valueForContract(value, unit), {\n      metadata: {\n        action: {\n          name: 'transfer',\n          from: this._web3.currentAddress(),\n          to,\n          amount: this._getCurrency(value, unit)\n        }\n      },\n      promise\n    });\n  }\n\n  transferFrom(\n    from,\n    to,\n    value,\n    { unit = this._currency, promise = undefined } = {}\n  ) {\n    return this._contract.transferFrom(\n      from,\n      to,\n      this._valueForContract(value, unit),\n      {\n        metadata: {\n          action: {\n            name: 'transfer',\n            from,\n            to,\n            amount: getCurrency(value, unit)\n          }\n        },\n        promise\n      }\n    );\n  }\n\n  _getCurrency(amount, unit) {\n    if (unit == this._currency) return this._currency(amount);\n    return getCurrency(amount, unit);\n  }\n}\n",
        "import { getCurrency, ETH } from '../Currency';\nimport tracksTransactions from '../../utils/tracksTransactions';\nimport { ethers } from 'ethers';\n\nexport default class EtherToken {\n  _web3;\n  _gasService;\n  _transactionManager;\n  constructor(web3Service, gasService, transactionManager) {\n    this._web3 = web3Service;\n    this._gasService = gasService;\n    this._transactionManager = transactionManager;\n  }\n\n  // eslint-disable-next-line\n  allowance(tokenOwner, spender) {\n    return Promise.resolve(Number.MAX_SAFE_INTEGER);\n  }\n\n  balance() {\n    return this.balanceOf(this._web3.currentAddress());\n  }\n\n  async balanceOf(owner) {\n    return ETH.wei(await this._web3.getBalance(owner));\n  }\n\n  // eslint-disable-next-line\n  approve(spender, value) {\n    return Promise.resolve(true);\n  }\n\n  // eslint-disable-next-line\n  approveUnlimited(spender) {\n    return Promise.resolve(true);\n  }\n\n  @tracksTransactions\n  async transfer(toAddress, amount, options) {\n    return this.transferFrom(\n      this._web3.currentAddress(),\n      toAddress,\n      amount,\n      options\n    );\n  }\n\n  @tracksTransactions\n  async transferFrom(fromAddress, toAddress, amount, { unit = ETH, promise }) {\n    const curAmt = ethers.BigNumber.from(\n      getCurrency(amount, unit).toFixed('wei')\n    )._hex;\n    return this._transactionManager.sendTransaction(\n      {\n        from: fromAddress,\n        to: toAddress,\n        value: curAmt\n      },\n      {\n        metadata: {\n          action: {\n            name: 'transfer',\n            from: fromAddress,\n            to: toAddress,\n            amount: getCurrency(amount, unit)\n          }\n        },\n        promise\n      }\n    );\n  }\n}\n",
        "import Erc20Token from './Erc20Token';\nimport { ETH, WETH } from '../Currency';\n\nexport default class WethToken extends Erc20Token {\n  constructor(contract, web3Service, decimals) {\n    super(contract, web3Service, decimals, 'WETH');\n  }\n\n  name() {\n    return this._contract.name();\n  }\n\n  deposit(amount, { unit = ETH, ...options } = {}) {\n    return this._contract.deposit({\n      value: this._valueForContract(amount, unit),\n      ...options\n    });\n  }\n\n  withdraw(amount, { unit = WETH, ...options } = {}) {\n    const value = this._valueForContract(amount, unit);\n    return this._contract.withdraw(value, options);\n  }\n}\n",
        "import Erc20Token from './Erc20Token';\nimport { WETH, PETH } from '../Currency';\n\nexport default class PethToken extends Erc20Token {\n  _tub;\n  constructor(contract, web3Service, tub) {\n    super(contract, web3Service, 18, 'PETH');\n    this._tub = tub;\n  }\n\n  join(amount, { unit = WETH, promise = undefined } = {}) {\n    const value = this._valueForContract(amount, unit);\n    return this._tub.join(value, { promise });\n  }\n\n  exit(amount, { unit = PETH, promise = undefined } = {}) {\n    const value = this._valueForContract(amount, unit);\n    return this._tub.exit(value, { promise });\n  }\n\n  async wrapperRatio() {\n    return WETH.ray((await this._tub.per())._hex);\n  }\n\n  async joinPrice(amount, unit = WETH) {\n    const value = this._valueForContract(amount, unit);\n    return WETH.wei((await this._tub.ask(value))._hex);\n  }\n\n  async exitPrice(amount, unit = WETH) {\n    const value = this._valueForContract(amount, unit);\n    return WETH.wei((await this._tub.bid(value))._hex);\n  }\n}\n",
        "import { PrivateService } from '@makerdao/services-core';\nimport tokens from '../../contracts/tokens';\nimport contracts from '../../contracts/contracts';\nimport networks from '../../contracts/networks';\nimport Erc20Token from './tokens/Erc20Token';\nimport EtherToken from './tokens/EtherToken';\nimport WethToken from './tokens/WethToken';\nimport PethToken from './tokens/PethToken';\nimport ERC20TokenAbi from '../../contracts/abis/ERC20.json';\nimport assert from 'assert';\n\nexport default class EthereumTokenService extends PrivateService {\n  constructor(name = 'token') {\n    super(name, ['smartContract', 'web3', 'gas', 'transactionManager']);\n    this._tokens = tokens;\n    this._addedTokens = {};\n  }\n\n  initialize(settings = {}) {\n    if (settings.erc20) {\n      for (const token of settings.erc20) {\n        const symbol = token.symbol || token.currency.symbol;\n        this._tokens[symbol] = symbol;\n        this._addedTokens[symbol] = [token];\n      }\n    }\n\n    this._addressOverrides = settings.addressOverrides || {};\n  }\n\n  getTokens() {\n    return Object.keys(this._tokens);\n  }\n\n  // FIXME should be caching/memoizing here\n  getToken(symbol, version) {\n    // support passing in Currency constructors\n    if (symbol.symbol) symbol = symbol.symbol;\n\n    assert(symbol, 'Symbol is blank');\n    assert(\n      this.getTokens().indexOf(symbol) >= 0,\n      `Symbol \"${symbol}\" is not recognized`\n    );\n\n    if (symbol === tokens.ETH) {\n      return new EtherToken(\n        this.get('web3'),\n        this.get('gas'),\n        this.get('transactionManager')\n      );\n    }\n\n    const { address, decimals, abi, currency } = this._getTokenInfo(\n      symbol,\n      version\n    );\n\n    const scs = this.get('smartContract');\n    const contract = scs.getContractByAddressAndAbi(\n      address,\n      abi || ERC20TokenAbi\n    );\n\n    if (symbol === tokens.WETH) {\n      return new WethToken(contract, this.get('web3'), decimals);\n    }\n\n    if (symbol === tokens.PETH) {\n      if (decimals !== 18) {\n        throw new Error('PethToken code hardcodes 18 decimal places.');\n      }\n      const tub = scs.getContract(contracts.SAI_TUB);\n      return new PethToken(contract, this.get('web3'), tub);\n    }\n\n    return new Erc20Token(\n      contract,\n      this.get('web3'),\n      decimals || 18,\n      symbol,\n      currency\n    );\n  }\n\n  _getTokenInfo(symbol, version) {\n    let { network, networkName } = this.get('web3');\n    const tokenInfoList =\n      this._addedTokens[symbol] || this._getNetworkMapping(network)[symbol];\n\n    assert(tokenInfoList, `Cannot find token info for \"${symbol}\"`);\n\n    const tokenInfo = version\n      ? tokenInfoList[version - 1]\n      : tokenInfoList[tokenInfoList.length - 1];\n\n    if (this._addressOverrides[symbol])\n      tokenInfo.address = this._addressOverrides[symbol];\n\n    if (typeof tokenInfo.address === 'string') return tokenInfo;\n\n    return {\n      ...tokenInfo,\n      address:\n        tokenInfo.address[networkName === 'test' ? 'testnet' : networkName]\n    };\n  }\n\n  _getNetworkMapping(networkId) {\n    const mapping = networks.filter(m => m.networkId === networkId);\n\n    if (mapping.length < 1) {\n      throw new Error('networkId not found');\n    }\n\n    return mapping[0].contracts;\n  }\n\n  _selectTokenVersions(mapping) {\n    const tokenArray = [];\n\n    for (let token in tokens) {\n      if (token === 'ETH') {\n        tokenArray['ETH'] = [1];\n      }\n\n      if (token in mapping) {\n        let versionArray = [];\n        mapping[token].forEach(e => {\n          versionArray.push(e.version);\n        });\n        tokenArray[token] = versionArray;\n      }\n    }\n\n    return tokenArray;\n  }\n}\n",
        "import networks from '../../contracts/networks';\n\nexport function captureConsole(cb) {\n  // eslint-disable-next-line\n  const origConsoleLog = console.log,\n    output = [];\n\n  // eslint-disable-next-line\n  console.log = (...args) => args.forEach(a => output.push(a));\n\n  cb();\n\n  // eslint-disable-next-line\n  console.log = origConsoleLog;\n}\n\nexport function promisify(fn) {\n  return function(...args) {\n    return new Promise((resolve, reject) => {\n      fn.apply(\n        this,\n        args.concat((err, value) => (err ? reject(err) : resolve(value)))\n      );\n    });\n  };\n}\n\nexport function getNetworkName(networkId) {\n  const result = networks.filter(n => n.networkId === networkId);\n\n  if (result.length < 1) {\n    throw new Error('No network with ID ' + networkId + ' found.');\n  }\n\n  return result[0].name;\n}\n\nexport function slug() {\n  return (\n    '-' +\n    Math.random()\n      .toString(36)\n      .substring(2, 7) +\n    Math.random()\n      .toString(36)\n      .substring(2, 7)\n  );\n}\n\nexport function promiseWait(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// https://stackoverflow.com/a/43963612/56817\nexport const uniqueId = (() => {\n  let currentId = 0;\n  const map = new WeakMap();\n\n  return object => {\n    if (!map.has(object)) {\n      map.set(object, ++currentId);\n    }\n\n    return map.get(object);\n  };\n})();\n",
        "import { isEqual } from 'lodash';\n//////////////////////////////\n/////  Polling Helpers  //////\n//////////////////////////////\n\nexport function createPayloadFetcher(payloadGetterMap) {\n  return () => {\n    return Promise.all(\n      Object.entries(payloadGetterMap).map(([key, getter]) =>\n        getter().then(state => [key, state])\n      )\n    ).then(states => {\n      const payload = {};\n      for (const [key, state] of states) {\n        payload[key] = state;\n      }\n      return payload;\n    });\n  };\n}\n\nexport function createMemoizedPoll({\n  type,\n  getState,\n  emit,\n  curr = {},\n  live = false\n}) {\n  return {\n    async ping() {\n      if (!live) return;\n      try {\n        const next = await getState();\n        if (!isEqual(curr, next)) {\n          emit(type, next);\n          curr = next;\n        }\n      } catch (err) {\n        const msg = `Failed to get latest ${type} state. Message -> ${err}`;\n        emit('error', msg);\n      }\n    },\n    async heat() {\n      if (live) return;\n      try {\n        curr = await getState();\n        live = true;\n      } catch (err) {\n        const msg = `Failed to get initial ${type} state. Message -> ${err}`;\n        emit('error', msg);\n      }\n    },\n    cool() {\n      if (!live) return;\n      live = false;\n    },\n    type() {\n      return type;\n    },\n    live() {\n      return live;\n    }\n  };\n}\n",
        "import { createMemoizedPoll, createPayloadFetcher } from './helpers';\nimport EventEmitterObj from 'eventemitter2';\nconst { EventEmitter2 } = EventEmitterObj;\n\nexport default class EventEmitter {\n  constructor(disposeSelf) {\n    this._emitter = new EventEmitter2({\n      wildcard: true,\n      delimiter: '/'\n    });\n    this._polls = [];\n    this._block = null;\n    this._sequenceNum = 1;\n    this._disposeSelf = disposeSelf;\n    this.emit = this.emit.bind(this);\n  }\n\n  emit(event, payload = {}, block = this._getBlock()) {\n    // if nobody's listening for this event, don't actually emit it\n    if (this._emitter.listeners(event).length === 0) return;\n    const eventObj = {\n      payload,\n      block,\n      type: event,\n      sequence: this._sequenceNum\n    };\n    this._sequenceNum++;\n    this._emitter.emit(event, eventObj);\n  }\n\n  on(event, listener) {\n    this._emitter.on(event, listener);\n    // start polling for state changes if the associated event now has a listener\n    this._polls.forEach(\n      poll => this._emitter.listeners(poll.type()).length > 0 && poll.heat()\n    );\n  }\n\n  removeListener(event, listener) {\n    this._emitter.removeListener(event, listener);\n    // stop polling for state changes if the associated event no longer has a listener\n    this._polls.forEach(\n      poll => this._emitter.listeners(poll.type()).length === 0 && poll.cool()\n    );\n  }\n\n  registerPollEvents(eventPayloadMap) {\n    for (const [eventType, payloadGetterMap] of Object.entries(\n      eventPayloadMap\n    )) {\n      const payloadFetcher = createPayloadFetcher(payloadGetterMap);\n      const memoizedPoll = createMemoizedPoll({\n        type: eventType,\n        emit: this.emit,\n        getState: payloadFetcher\n      });\n      this._polls.push(memoizedPoll);\n    }\n    return this;\n  }\n\n  ping(block) {\n    this._setBlock(block);\n    this._polls.forEach(poll => poll.ping());\n  }\n\n  dispose() {\n    this.emit = () => {};\n    this.on = () => {};\n    this._disposeSelf();\n  }\n\n  _setBlock(block) {\n    if (block !== undefined) this._block = block;\n  }\n\n  _getBlock() {\n    return this._block;\n  }\n\n  // For testing\n\n  _startPolls() {\n    this._polls.forEach(poll => poll.heat());\n  }\n\n  _stopPolls() {\n    this._polls.forEach(poll => poll.cool());\n  }\n}\n",
        "import { PrivateService } from '@makerdao/services-core';\nimport { slug } from '../index';\nimport EventEmitter from './EventEmitter';\nimport debug from 'debug';\nconst log = debug('dai:EventService');\n\nexport default class EventService extends PrivateService {\n  /**\n   * @param {string} name\n   */\n  constructor(name = 'event') {\n    super(name, []);\n\n    this._block = null;\n    // all of our emitters  we can have many of these\n    // e.g. one for our maker object, a couple for some cdp objects, a few more on transaction objects, etc\n    this.emitters = {};\n\n    // this is our default emitter, it will likely be the maker object's personal emitter\n    this.buildEmitter({ defaultEmitter: true });\n\n    this.ping = this.ping.bind(this);\n  }\n\n  // check all of our active polls for new state\n  // this is currently called on every new block from Web3Service\n  ping(block) {\n    Object.values(this.emitters).forEach(emitter => emitter.ping(block));\n  }\n\n  // add a event listener to an emitter\n  on(event, listener, emitter = this._defaultEmitter()) {\n    emitter.on(event, listener);\n  }\n\n  // push an event through an emitter\n  emit(event, payload, block, emitter = this._defaultEmitter()) {\n    emitter.emit(event, payload, block);\n  }\n\n  // remove a listener from an emitter\n  removeListener(event, listener, emitter = this._defaultEmitter()) {\n    emitter.removeListener(event, listener);\n  }\n\n  registerPollEvents(eventPayloadMap, emitter = this._defaultEmitter()) {\n    return emitter.registerPollEvents(eventPayloadMap);\n  }\n\n  buildEmitter({ defaultEmitter = false } = {}) {\n    const id = defaultEmitter ? 'default' : slug();\n    const disposeEmitter = this._disposeEmitter.bind(this, id);\n    const newEmitter = new EventEmitter(disposeEmitter);\n    newEmitter.on('error', eventObj => this._logError(id, eventObj.payload));\n    this.emitters[id] = newEmitter;\n    return newEmitter;\n  }\n\n  _disposeEmitter(id) {\n    if (id === 'default') {\n      this._logError(id, 'cannot dispose default emitter');\n    } else delete this.emitters[id];\n  }\n\n  _defaultEmitter() {\n    return this.emitters.default;\n  }\n\n  _logError(name, msg) {\n    log(`Problem encountered in emitter ${name} -> ${msg}`);\n  }\n}\n",
        "import { PublicService } from '@makerdao/services-core';\nimport { map } from 'lodash';\nimport fetch from 'isomorphic-fetch';\n\nexport const API_URL =\n  'https://ethgasstation.info/json/ethgasAPI.json?api-key=';\n\nexport default class GasService extends PublicService {\n  constructor(name = 'gas') {\n    super(name, ['web3']);\n    this._fallback = 4000000;\n    this._multiplier = 1.55;\n    this._transactionSpeed = 'fast';\n  }\n\n  initialize(settings) {\n    if (settings) {\n      this._parseConfig(settings.limit, 'limit');\n      this._parseConfig(settings.price, 'price');\n    }\n\n    this._settings = settings || {};\n\n    this._gasStationDataPromise = this.disablePrice\n      ? Promise.resolve({})\n      : this.fetchGasStationData();\n  }\n\n  _parseConfig(settings = 'default', label) {\n    return settings === 'default' || typeof settings === 'object'\n      ? this._setProperties(settings, label)\n      : (this[label] = settings);\n  }\n\n  _setProperties(settings, label) {\n    if (settings === 'default') return;\n\n    return map(settings, (value, key) => {\n      if (key === 'disable') {\n        this[\n          'disable' + label.charAt(0).toUpperCase() + label.slice(1)\n        ] = value;\n      } else {\n        this[key] = value;\n      }\n    });\n  }\n\n  async fetchGasStationData() {\n    try {\n      const response = await fetch(API_URL + this._settings.apiKey);\n      return response.json();\n    } catch (err) {\n      console.error('Error fetching gas data; disabling preset gas price', err);\n      this.disablePrice = true;\n    }\n  }\n\n  async getGasPrice(txSpeed) {\n    if (this.price) return this.price;\n    const speedSetting = txSpeed ? txSpeed : this.transactionSpeed;\n    const gasStationData = await this._gasStationDataPromise;\n    const price = this.get('web3')._web3.utils.toWei(\n      (gasStationData[speedSetting] / 10).toString(),\n      'gwei'\n    );\n\n    return price;\n  }\n\n  async getWaitTime(txSpeed) {\n    const speedSetting = txSpeed ? txSpeed : this.transactionSpeed;\n    const gasStationData = await this._gasStationDataPromise;\n\n    return gasStationData[`${speedSetting}Wait`];\n  }\n\n  async estimateGasLimit(transaction) {\n    if (this.limit) return this.limit;\n    if (this.disableLimit) return this.fallback;\n\n    let web3Data = [];\n    try {\n      web3Data = await Promise.all([\n        this.get('web3').getBlock('latest'),\n        this.get('web3').estimateGas(transaction)\n      ]);\n    } catch (err) {\n      return this.fallback;\n    }\n\n    const blockLimit = web3Data[0].gasLimit;\n    const estimate = web3Data[1];\n\n    if (!this.multiplier && !this.absolute) {\n      return Math.min(this.absolute, blockLimit);\n    } else if (!this.absolute) {\n      return Math.min(parseInt(estimate * this.multiplier), blockLimit);\n    } else {\n      return Math.min(\n        parseInt(estimate * this.multiplier),\n        this.absolute,\n        blockLimit\n      );\n    }\n  }\n\n  get multiplier() {\n    return this._multiplier;\n  }\n\n  set multiplier(number) {\n    if (number <= 0) {\n      throw new Error('Gas limit multiplier must be greater than 0');\n    }\n\n    this._multiplier = number;\n  }\n\n  get absolute() {\n    return this._absolute;\n  }\n\n  set absolute(number) {\n    if (number <= 0) {\n      throw new Error('Absolute gas limit must be greater than 0');\n    }\n\n    this._absolute = number;\n  }\n\n  get fallback() {\n    return this._fallback;\n  }\n\n  set fallback(number) {\n    if (number <= 0) {\n      throw new Error('Fallback gas limit must be greater than 0');\n    }\n\n    this._fallback = number;\n  }\n\n  get transactionSpeed() {\n    return this._transactionSpeed;\n  }\n\n  set transactionSpeed(speed) {\n    const validKeys = ['average', 'fast', 'fastest', 'safeLow'];\n    if (!validKeys.includes(speed)) {\n      throw new Error(`Invalid transaction speed -- options are ${validKeys}`);\n    }\n\n    this._transactionSpeed = speed;\n  }\n\n  removeMultiplier() {\n    this._multiplier = null;\n  }\n\n  removeAbsolute() {\n    this._absolute = null;\n  }\n\n  removeFallback() {\n    this._fallback = null;\n  }\n}\n",
        "// TODO: Rewrite this service to make it more simple\n// @ts-nocheck\n/* eslint-disable */\nimport { PublicService } from '@makerdao/services-core';\nimport { createWatcher } from '@makerdao/multicall';\nimport debug from 'debug';\nimport { Observable, ReplaySubject, combineLatest, from, throwError, timer } from 'rxjs';\nimport {\n  map,\n  flatMap,\n  debounceTime,\n  take,\n  catchError,\n  filter,\n  takeUntil,\n  throwIfEmpty,\n  tap\n} from 'rxjs/operators';\n\nimport { get, set, find } from 'lodash';\n\nconst log = debug('dai:MulticallService');\nconst log2 = debug('dai:MulticallService:observables');\n\nconst throwIfErrorInValues = values => values.map(v => { if (v instanceof Error) throw v; }); // prettier-ignore\nconst checkForErrors = values => find(values, v => v instanceof Error) === undefined;\nconst catchNestedErrors = key => f =>\n  catchError(err => {\n    log2(`Caught nested error in ${key}: ${err}`);\n    return from([new Error(err)]);\n  })(f);\n\nexport default class MulticallService extends PublicService {\n  _schemas = [];\n  _schemaByObservableKey = {};\n  _schemaInstances = {};\n  _subjects = {};\n  _observables = {};\n  _watcherUpdates = null;\n  _schemaSubscribers = {};\n  _totalSchemaSubscribers = 0;\n  _totalActiveSchemas = 0;\n  _multicallResultCache = {};\n  _addresses = {};\n  _removeSchemaTimers = {};\n  _removeSchemaDelay;\n  _debounceTime;\n  _latestDebounceTime;\n  _latestTimeout;\n  _connectedAddress;\n  _watcher;\n\n  constructor(name = 'multicall') {\n    super(name, ['web3', 'smartContract']);\n\n    this._schemas = [];\n    this._schemaByObservableKey = {};\n    this._schemaInstances = {};\n    this._subjects = {};\n    this._observables = {};\n    this._watcherUpdates = null;\n    this._schemaSubscribers = {};\n    this._totalSchemaSubscribers = 0;\n    this._totalActiveSchemas = 0;\n    this._multicallResultCache = {};\n    this._addresses = {};\n    this._removeSchemaTimers = {};\n  }\n\n  initialize(\n    settings = {\n      addresses: undefined,\n      removeSchemaDelay: 1000,\n      debounceTime: 1,\n      latestDebounceTime: 1,\n      latestTimeout: 10000\n    }\n  ) {\n    this._addresses = settings.addresses || this.get('smartContract').getContractAddresses();\n    this._removeSchemaDelay = settings.removeSchemaDelay || 1000;\n    this._debounceTime = settings.debounceTime || 1;\n    this._latestDebounceTime = settings.latestDebounceTime || 1;\n    this._latestTimeout = settings.latestTimeout || 10000;\n  }\n\n  authenticate() {\n    this._connectedAddress = this.get('web3').currentAddress();\n  }\n\n  createWatcher({ useWeb3Provider = false, interval = 'block', rpcUrl = '', ...config } = {}) {\n    const web3 = this.get('web3');\n    config = {\n      multicallAddress: this.get('smartContract').getContractAddress('MULTICALL'),\n      ...config\n    };\n\n    const onNewBlockPolling = interval === 'block';\n    if (onNewBlockPolling) interval = 60000; // 1 min polling fallback safeguard\n\n    if (useWeb3Provider) config.web3 = web3._web3;\n    else if (!rpcUrl) {\n      if (!web3.rpcUrl) new Error('Unable to get rpcUrl for multicall');\n      rpcUrl = web3.rpcUrl;\n    }\n\n    this._watcher = createWatcher([], { ...config, interval, rpcUrl });\n\n    if (onNewBlockPolling) {\n      log(`Watcher created with poll on new block mode using ${rpcUrl ? `rpcUrl: ${rpcUrl}` : 'web3 provider'}`); // prettier-ignore\n      web3.onNewBlock(blockNumber => {\n        log(`Polling after new block detected (${blockNumber})`);\n        this._watcher.poll();\n      });\n    } else {\n      log(\n        `Watcher created with ${interval}ms polling interval using ${\n          useWeb3Provider ? 'web3 provider' : `rpcUrl: ${rpcUrl}`\n        }`\n      );\n    }\n\n    this._watcher.onPoll(({ id, latestBlockNumber: block }) =>\n      log(`Sending network request #${id}${block ? ` (latest block: ${block})` : ''}`)\n    );\n    this._watcher.onNewBlock(block => log(`Latest block: ${block}`));\n    this._watcher.onError(err => console.error('Multicall error:', err));\n\n    return this._watcher;\n  }\n\n  tap(cb) {\n    log('Watcher tapped');\n    return this._watcher.tap(cb);\n  }\n\n  start() {\n    log('Watcher started');\n    return this._watcher.start();\n  }\n\n  stop() {\n    this._flushPendingSchemaRemovals();\n    log('Watcher stopped');\n    return this._watcher.stop();\n  }\n\n  restart() {\n    this.stop();\n    this.start();\n  }\n\n  schemaByObservableKey(key) {\n    if (!key) throw new Error('Invalid observable key');\n    if (!this._schemaByObservableKey[key])\n      throw new Error(`No registered schema definition found with observable key: ${key}`);\n    return this._schemaByObservableKey[key];\n  }\n\n  get observableKeys() {\n    return Object.keys(this._schemaByObservableKey);\n  }\n\n  get watcher() {\n    return this._watcher;\n  }\n\n  get activeSchemas() {\n    return this._watcher.schemas.filter(({ id }) => id); // Filter only schemas with id\n  }\n\n  get activeSchemaIds() {\n    return this.activeSchemas.map(({ id }) => id);\n  }\n\n  get totalActiveSchemas() {\n    return this._totalActiveSchemas;\n  }\n\n  get totalSchemaSubscribers() {\n    return this._totalSchemaSubscribers;\n  }\n\n  // Register schema definitions\n  registerSchemas(schemas) {\n    if (typeof schemas !== 'object') throw new Error('Schemas must be object or array');\n\n    // If schemas is key/val object use key as schema key and convert to array object\n    if (!Array.isArray(schemas)) schemas = Object.keys(schemas).map(key => ({ key, ...schemas[key] })); // prettier-ignore\n    // Clone if array\n    else schemas = schemas.map(item => ({ ...item }));\n\n    schemas.forEach(schema => {\n      if (!schema.key) throw new Error('Schema definitions must have a unique key');\n      // Automatically use schema key as return key if no return keys specified\n      if (!schema.return && !schema.returns) schema.returns = [schema.key];\n      if (schema.return && schema.returns) throw new Error('Ambiguous return definitions in schema: found both return and returns property'); // prettier-ignore\n      if (schema.return) schema.returns = [schema.return];\n      if (!Array.isArray(schema.returns))\n        throw new Error('Schema must contain return/returns property');\n      // Use return keys to create observable key => schema mapping\n      // and normalize as array of [key, transform] arrays\n      schema.returns = schema.returns.map(ret => {\n        if (!Array.isArray(ret)) ret = [ret];\n        if (this._schemaByObservableKey[ret[0]] !== undefined)\n          throw new Error(`Observable with key ${ret[0]} already registered`);\n        this._schemaByObservableKey[ret[0]] = schema;\n        if (ret.length > 2) throw new Error('Returns array format should be [key, transform]');\n        return ret;\n      });\n    });\n    this._schemas = [...this._schemas, ...schemas];\n    log2(`Registered ${schemas.length} schemas`);\n  }\n\n  latest(key, ...args) {\n    const obsPath = `${key}${args.length > 0 ? '.' : ''}${args.join('.')}`;\n    return this._watch({ depth: 0, throwIfError: true }, key, ...args)\n      .pipe(\n        catchError(err => {\n          throw new Error(err);\n        }),\n        takeUntil(timer(this._latestTimeout)),\n        throwIfEmpty(() => new Error(`Timed out waiting for latest value of: ${obsPath}`)),\n        debounceTime(this._latestDebounceTime),\n        take(1)\n      )\n      .toPromise();\n  }\n\n  watch(key, ...args) {\n    return this._watch({ depth: 0 }, key, ...args);\n  }\n\n  _watch({ depth, throwIfError = false }, key, ...args) {\n    // Find schema definition associated with this observable key\n    const schemaDefinition = this.schemaByObservableKey(key);\n    const expectedArgs = schemaDefinition.generate.length;\n    if (args.length < expectedArgs)\n      return throwError(`Observable ${key} expects at least ${expectedArgs} argument(s)`);\n\n    const obsPath = `${key}${args.length > 0 ? '.' : ''}${args.join('.')}`;\n\n    // Validate arguments using schema args validator\n    if (schemaDefinition?.validate?.args) {\n      const validate = schemaDefinition.validate.args(...args);\n      if (validate) {\n        log2(`Input validation failed for observable: ${obsPath} (depth: ${depth})`);\n        return throwError(validate);\n      }\n    }\n\n    // Create or get existing schema instance for this instance path (schema definition + args)\n    const schemaInstance = this._createSchemaInstance(schemaDefinition, ...args);\n    const { computed } = schemaInstance;\n    log2(`watch() called for ${computed ? 'computed ' : 'base '}observable: ${obsPath} (depth: ${depth})`); // prettier-ignore\n\n    // Return existing observable if one already exists for this observable path (key + args)\n    let existing = get(this._observables, obsPath);\n    if (existing) {\n      if (computed) {\n        log2(`Returning existing computed observable: ${obsPath} (depth: ${depth})`);\n        // Only debounce if call to watch() is not nested\n        if (depth === 0) existing = existing.pipe(debounceTime(this._debounceTime));\n        if (throwIfError) existing = existing.pipe(tap(throwIfErrorInValues));\n        return existing.pipe(\n          // Don't pass values to computed() if any of them are errors\n          filter(checkForErrors),\n          // Pass values to computed() on the computed observable\n          map(result => computed(...result))\n        );\n      }\n      log2(`Returning existing base observable: ${obsPath}`);\n      return existing;\n    }\n\n    // Handle computed observable\n    if (computed) {\n      // Handle dynamically generated dependencies\n      const dependencies =\n        typeof schemaInstance.dependencies === 'function'\n          ? schemaInstance.dependencies({\n              watch: this.watch.bind(this),\n              get: this.get.bind(this)\n            })\n          : schemaInstance.dependencies;\n\n      const recurseDependencyTree = trie_ => {\n        const key = trie_[0];\n        const trie = trie_.slice(1);\n\n        // If the dependency key provided is a function, promise or array of\n        // values then this dependency is providing its own custom value\n        // rather than specifying an existing observable key\n        if (key instanceof Promise || Array.isArray(key)) return from(key);\n        if (typeof key === 'function') return from(key());\n\n        const indexesAtLeafNodes = trie.map(node => !Array.isArray(node));\n        const allLeafNodes = indexesAtLeafNodes.every(node => node === true);\n\n        if (Array.isArray(trie) && trie.length === 0) {\n          // When trie is an empty array, indicates that we only need to return\n          // watch on the key\n          return this._watch({ depth: depth + 1 }, key);\n        } else if (allLeafNodes) {\n          // If the trie is an array it indicates that the observable is\n          // expecting arguments. These can be normal values or other\n          // observables. Where an index in the trie is an array, it is\n          // assumed that it is syntax for an observable argument. In the case\n          // where all indexes in the trie array are normal values, we use the\n          // spread operator to pass them to the returned watch fn\n          return this._watch({ depth: depth + 1 }, key, ...trie);\n        } else {\n          // When a trie array has nested observables, recursively call this fn\n          // on indexes which have an array.\n          return combineLatest(\n            trie.map((node, idx) => {\n              return indexesAtLeafNodes[idx] ? [node] : recurseDependencyTree(node);\n            })\n          ).pipe(\n            flatMap(result =>\n              this._watch({ depth: depth + 1 }, key, ...result).pipe(catchNestedErrors(key))\n            )\n          );\n        }\n      };\n\n      const dependencySubs = dependencies.map(recurseDependencyTree);\n      let observable = combineLatest(dependencySubs);\n\n      log2(`Created new computed observable: ${obsPath} (depth: ${depth})`);\n      set(this._observables, obsPath, observable);\n      // Only debounce if call to watch() is not nested\n      if (depth === 0) observable = observable.pipe(debounceTime(this._debounceTime));\n      if (throwIfError) observable = observable.pipe(tap(throwIfErrorInValues));\n      return observable.pipe(\n        // Don't pass values to computed() if any of them are errors\n        filter(checkForErrors),\n        // Pass values to computed() on the computed observable\n        map(result => computed(...result))\n      );\n    }\n\n    // This is a base observable\n    const { id, path } = schemaInstance;\n    if (this._schemaSubscribers[path] === undefined) this._schemaSubscribers[path] = 0;\n    const subject = new ReplaySubject(1);\n    set(this._subjects, obsPath, subject);\n    // Handle initial value if cached result from multicall exists\n    if (this._multicallResultCache[obsPath] !== undefined)\n      this._handleResult(subject, obsPath, this._multicallResultCache[obsPath]);\n\n    // Create base observable\n    const observable = Observable.create(observer => {\n      this._totalSchemaSubscribers++;\n      log2(`Observer subscribed to ${id} (${this._schemaSubscribers[path] + 1} subscribers)`);\n      // If first subscriber to this schema add it to multicall\n      if (++this._schemaSubscribers[path] === 1) this._addSchemaToMulticall(schemaInstance);\n      // Subscribe to watcher updates and emit them to subjects\n      if (!this._watcherUpdates) this._subscribeToWatcherUpdates();\n      // Subscribe this observer to the subject for this base observable\n      const sub = subject.subscribe(observer);\n      // Return the function to call when this observer unsubscribes\n      return () => {\n        this._totalSchemaSubscribers--;\n        // If last unsubscriber from this schema remove it from multicall\n        if (--this._schemaSubscribers[path] === 0)\n          this._removeSchemaFromMulticall(schemaInstance.id);\n        // Unsubscribe this observer from the subject for this base observable\n        sub.unsubscribe();\n        log2(`Observer unsubscribed from ${id} (${this._schemaSubscribers[path]} subscribers)`); // prettier-ignore\n      };\n    });\n\n    log2(`Created new base observable: ${obsPath}`);\n    set(this._observables, obsPath, observable);\n    return observable;\n  }\n\n  _createSchemaInstance(schemaDefinition, ...args) {\n    const path = args.join('.');\n    const instancePath = `${schemaDefinition.key}${path ? '.' : ''}${path}`;\n\n    // Return existing schema if found for this instance path (schema key + args)\n    if (this._schemaInstances[instancePath]) return this._schemaInstances[instancePath];\n\n    // Generate schema instance\n    const schemaInstance = schemaDefinition.generate(...args);\n    this._schemaInstances[instancePath] = schemaInstance;\n    schemaInstance.args = [...args];\n\n    // Auto generate some fields if this is a base schema\n    if (!schemaInstance.computed) {\n      const { returns, transforms = {} } = schemaInstance;\n      schemaInstance.path = instancePath;\n      // Auto generate return keys for schema instance if not provided by generate()\n      if (!returns) {\n        schemaInstance.returns = schemaDefinition.returns.map(ret => {\n          const key = ret[0];\n          const fullPath = `${key}${path ? '.' : ''}${path}`;\n          return transforms[key]\n            ? [fullPath, transforms[key]] // Use transform mapping in generated schema instance if available\n            : ret.length == 2\n            ? [fullPath, ret[1]]\n            : [fullPath];\n        });\n      }\n      // Resolve target contract address if contract string is provided\n      const { target, contract } = schemaInstance;\n      if (!target && !contract) throw new Error('Schema must specify target address or contract');\n      if (!target && !this._addresses[contract]) throw new Error(`Can't find contract address for ${contract}`); // prettier-ignore\n      schemaInstance.target = target || this._addresses[contract];\n    }\n\n    return schemaInstance;\n  }\n\n  _addSchemaToMulticall(schemaInstance) {\n    const { id, target, call, returns } = schemaInstance;\n    // If schema already added but pending removal then cancel pending removal\n    if (this._removeSchemaTimers[id]) {\n      log2(`Cancelled pending schema removal: ${id}`);\n      clearTimeout(this._removeSchemaTimers[id]);\n      delete this._removeSchemaTimers[id];\n      return;\n    }\n    this._totalActiveSchemas++;\n    this._watcher.tap(calls => [\n      ...calls,\n      {\n        id,\n        target,\n        call,\n        returns\n      }\n    ]);\n    log2(`Schema added to multicall: ${id}`);\n    if (process?.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);\n    else log2(`Active schemas (${this._totalActiveSchemas} total): ${this.activeSchemaIds.join(',')}`); // prettier-ignore\n  }\n\n  _removeSchemaImmediately(id) {\n    if (this._removeSchemaTimers[id] !== undefined) delete this._removeSchemaTimers[id];\n    log2(`Schema removed from multicall: ${id}`);\n    this._watcher.tap(schemas => schemas.filter(({ id: id_ }) => id_ !== id));\n    // If there are no active schemas unsubscribe from watcher updates\n    if (--this._totalActiveSchemas === 0) {\n      log2('No remaining active schemas');\n      log2('Unsubscribed from watcher updates');\n      this._watcherUpdates.unsub();\n      this._watcherUpdates = null;\n    } else {\n      if (process?.browser) log2('Active schemas (' + this._totalActiveSchemas + ' total):', this.activeSchemaIds);\n      else log2(`Active schemas (${this._totalActiveSchemas} remaining): ${this.activeSchemaIds.join(',')}`); // prettier-ignore\n    }\n  }\n\n  _removeSchemaFromMulticall(id) {\n    this._removeSchemaTimers[id] = setTimeout(\n      () => this._removeSchemaImmediately(id),\n      this._removeSchemaDelay\n    );\n  }\n\n  _flushPendingSchemaRemovals() {\n    const schemaTimers = Object.keys(this._removeSchemaTimers);\n    if (schemaTimers.length === 0) return;\n    log2(`Flushing ${schemaTimers.length} pending schema removals`);\n    for (let id of schemaTimers) {\n      log2(`Forcing schema removal: ${id}`);\n      clearTimeout(this._removeSchemaTimers[id]);\n      this._removeSchemaImmediately(id);\n    }\n  }\n\n  _handleResult(subject, obsPath, value) {\n    const err = this._validateResult(subject, obsPath, value);\n    // Trigger error on observable or emit result value to observable\n    if (err) subject.error(err);\n    else subject.next(value);\n  }\n\n  _validateResult(subject, obsPath, value) {\n    let [observableKey, ...args] = obsPath.split('.');\n    const schemaDefinition = this._schemaByObservableKey[observableKey];\n    const instancePath = `${schemaDefinition.key}${args.length > 0 ? '.' : ''}${args.join('.')}`;\n    const schemaInstance = this._schemaInstances[instancePath];\n    // Pass validation if no validator found for this schema definition\n    if (!schemaDefinition.validate?.hasOwnProperty(observableKey)) return;\n    try {\n      // Call validation func on schema definition for result value and pass schema instance args\n      // as 2nd param and also this context\n      const validate = schemaDefinition.validate[observableKey].call(\n        { args: schemaInstance.args },\n        value,\n        schemaInstance.args\n      );\n      if (validate) throw new Error(validate);\n      return; // Pass validation\n    } catch (err) {\n      log2('Validation error for ' + obsPath + ' result:', value);\n      return err; // Fail validation\n    }\n  }\n\n  _subscribeToWatcherUpdates() {\n    log2('Subscribed to watcher updates');\n    this._watcherUpdates = this._watcher.subscribe(update => {\n      const subject = get(this._subjects, update.type);\n      if (subject) {\n        const logValue = update.value?._isBigNumber\n          ? `${update.value.toString()} (BigNumber)`\n          : update.value;\n        log2('Got watcher update for ' + update.type + ':', logValue);\n        this._handleResult(subject, update.type, update.value);\n      } else this._multicallResultCache[update.type] = update.value;\n    });\n  }\n}\n",
        "import { PublicService } from '@makerdao/services-core';\nimport { promisify } from '../utils';\n\nexport default class NonceService extends PublicService {\n  constructor(name = 'nonce') {\n    super(name, ['web3', 'accounts']);\n    this._counts = {};\n  }\n\n  async connect() {\n    this._accountsService = this.get('accounts');\n    this._web3Service = this.get('web3');\n    await this.setCounts();\n  }\n\n  async _getTxCount(address) {\n    return promisify(this._web3Service._web3.eth.getTransactionCount)(\n      address,\n      'pending'\n    );\n  }\n\n  _compareNonceCounts(txCount, address) {\n    if (txCount > this._counts[address]) {\n      return txCount;\n    } else {\n      return this._counts[address];\n    }\n  }\n\n  _removeDuplicateAddresses(accounts) {\n    const uniqueAddresses = [];\n    accounts.map(account => {\n      if (!uniqueAddresses.includes(account.address))\n        uniqueAddresses.push(account.address);\n    });\n    return uniqueAddresses;\n  }\n\n  async setCounts() {\n    const accountsList = await this._accountsService.listAccounts();\n    if (accountsList.length === 0) return;\n    const uniqueAddresses = this._removeDuplicateAddresses(accountsList);\n\n    return new Promise(resolve => {\n      accountsList.map(async account => {\n        const txCount = await this._getTxCount(account.address);\n        this._counts[account.address] = txCount;\n\n        if (Object.keys(this._counts).length === uniqueAddresses.length) {\n          resolve();\n        }\n      });\n    });\n  }\n\n  async getNonce() {\n    const address = this._web3Service.currentAddress();\n    const txCount = await this._getTxCount(address);\n    let nonce;\n\n    if (this._counts[address]) {\n      nonce = this._compareNonceCounts(txCount, address);\n      this._counts[address] += 1;\n    } else {\n      this._counts[address] = txCount;\n      nonce = txCount;\n      this._counts[address] += 1;\n    }\n\n    return nonce;\n  }\n}\n",
        "import { LocalService } from '@makerdao/services-core';\n\nconst _ = () => {};\n\nexport default class NullEventService extends LocalService {\n  /**\n   * @param {string} name\n   */\n  constructor(name = 'event') {\n    super(name);\n  }\n\n  on() {}\n  emit() {}\n  ping() {}\n  removeListener() {}\n  registerPollEvents() {}\n  buildEmitter() {\n    return {\n      emit: _,\n      on: _,\n      removeListener: _,\n      registerPollEvents: _,\n      ping: _,\n      dispose: _\n    };\n  }\n}\n",
        "import { PrivateService } from '@makerdao/services-core';\nimport contracts from '../../contracts/contracts';\nimport tokens from '../../contracts/tokens';\nimport networks, { contractAddressesInfo } from '../../contracts/networks';\nimport { Contract } from 'ethers';\nimport { wrapContract } from './smartContract/wrapContract';\nimport { mapValues } from 'lodash';\nimport assert from 'assert';\n\nexport default class SmartContractService extends PrivateService {\n  constructor(name = 'smartContract') {\n    super(name, ['web3', 'transactionManager']);\n\n    // aliases\n    this.getContractByName = this.getContract;\n    this.getContractAddressByName = this.getContractAddress;\n  }\n\n  initialize(settings = {}) {\n    if (settings.addContracts) {\n      this._addedContracts = Object.keys(settings.addContracts).reduce(\n        (acc, key) => {\n          const def = settings.addContracts[key];\n          acc[key] = [{ ...def, version: 1 }];\n          return acc;\n        },\n        {}\n      );\n    }\n\n    this._addressOverrides = settings.addressOverrides || {};\n\n    this.get('transactionManager')\n      .get('proxy')\n      .setSmartContractService(this);\n  }\n\n  getContractByAddressAndAbi(address, abi, { name, wrap = true } = {}) {\n    assert(address, `Missing address for contract \"${name}\"`);\n    if (!name) name = this.lookupContractName(address);\n\n    const web3Service = this.get('web3');\n    const signerOrProvider = web3Service.get('accounts').hasAccount()\n      ? web3Service.getEthersSigner()\n      : web3Service.getEthersSigner().provider;\n\n    const contract = new Contract(address, abi, signerOrProvider);\n    const txManager = wrap && this.get('transactionManager');\n    return wrapContract(contract, name, abi, txManager);\n  }\n\n  getContractAddress(name, { version } = {}) {\n    const { address } = this._getContractInfo(name, version);\n    return address;\n  }\n\n  getContractAddresses() {\n    return mapValues(\n      this._getAllContractInfo(),\n      versions => findLatestContractInfo(versions).address\n    );\n  }\n\n  getContract(name, { version, wrap = true } = {}) {\n    const info = this._getContractInfo(name, version);\n    return this.getContractByAddressAndAbi(info.address, info.abi, {\n      name,\n      wrap\n    });\n  }\n\n  lookupContractName(address) {\n    address = address.toUpperCase();\n    const contracts = this._getAllContractInfo();\n    for (let name of Object.keys(contracts)) {\n      const versions = contracts[name];\n      if (\n        versions.find(\n          info => info.address && info.address.toUpperCase() === address\n        )\n      ) {\n        return name;\n      }\n    }\n\n    return null;\n  }\n\n  hasContract(name) {\n    return (\n      Object.keys(contracts).indexOf(name) > -1 ||\n      Object.keys(tokens).indexOf(name) > -1 ||\n      Object.keys(this._addedContracts || {}).indexOf(name) > -1\n    );\n  }\n\n  // generally we should be using the ethers contract interface. this is only\n  // for edge cases that the ethers contract interface doesn't support, like\n  // calling (but not sending) a non-constant function\n  getWeb3ContractByName(name) {\n    const { abi, address } = this._getContractInfo(name);\n    return this.get('web3').web3Contract(abi, address);\n  }\n\n  _getContractInfo(name, version) {\n    assert(this.hasContract(name), `No contract found for \"${name}\"`);\n    const contracts = this._getAllContractInfo();\n    const contractInfo = findContractInfoForVersion(contracts[name], version);\n    assert(contractInfo, `Cannot find contract ${name}, version ${version}`);\n    assert(contractInfo.address, `Contract ${name} has no address`);\n    return contractInfo;\n  }\n\n  _getAllContractInfo() {\n    let { networkName } = this.get('web3');\n    const mapping = networks.find(m => m.name === networkName);\n    assert(mapping, `Network \"${networkName}\" not found in mapping.`);\n\n    if (!mapping.contracts)\n      mapping.contracts = contractAddressesInfo(this._addressOverrides);\n\n    if (!this._contractInfoCache) this._contractInfoCache = {};\n    if (!this._contractInfoCache[networkName]) {\n      const allContractInfo = this._addedContracts\n        ? {\n            ...mapping.contracts,\n            ...this._addedContracts\n          }\n        : mapping.contracts;\n\n      this._contractInfoCache[networkName] = mapValues(\n        allContractInfo,\n        (versions, name) => {\n          const latest = findLatestContractInfo(versions);\n          const address =\n            getSingleAddress(this._addressOverrides[name], networkName) ||\n            getSingleAddress(latest.address, networkName);\n          return address !== latest.address\n            ? versions.map(v => (v === latest ? { ...latest, address } : v))\n            : versions;\n        }\n      );\n    }\n\n    return this._contractInfoCache[networkName];\n  }\n}\n\nfunction findContractInfoForVersion(versions, version) {\n  if (!version) version = Math.max(...versions.map(info => info.version));\n  return versions.find(info => info.version === version);\n}\n\nfunction findLatestContractInfo(versions) {\n  return findContractInfoForVersion(versions);\n}\n\nfunction getSingleAddress(addressGroup, networkName) {\n  if (!addressGroup) return;\n\n  if (typeof addressGroup === 'string') return addressGroup;\n\n  if (addressGroup[networkName]) return addressGroup[networkName];\n\n  // some configuration uses 'testnet' instead of 'test' as the network name\n  if (networkName.startsWith('test') && addressGroup.testnet)\n    return addressGroup.testnet;\n\n  // return nothing if addressGroup has no address defined for this network\n}\n",
        "export function wrapContract(contract, name, abi, txManager) {\n  const nonConstantFns = {};\n  for (let { type, constant, name, inputs, stateMutability } of abi) {\n    // Non-constant functions can modify state\n    const canModifyState =\n      constant === false || !['pure', 'view'].includes(stateMutability);\n    if (type === 'function' && canModifyState) {\n      // Map all of the contract method names + sigs in cases where the method\n      // sig is used as the key due to method overloading, e.g.\n      // contract[\"method(address,uint256)\"](foo, bar)\n      if (inputs.length > 0) {\n        const methodSig = `${name}(${inputs.map(i => i.type).join(',')})`;\n        nonConstantFns[methodSig] = true;\n      }\n      // Currently assume that the default method chosen by Ethers when there\n      // are multiple overloaded methods of the same name is non-constant\n      nonConstantFns[name] = true;\n    }\n  }\n\n  // Why is the first argument an almost-empty object? The functions in\n  // ethers.Contract are set up as read-only, non-configurable properties, which\n  // means if we try to change their values with Proxy, we get an error.\n  //\n  // But that only happens if the contract is specified as the first argument to\n  // Proxy. So we don't do that. Go on, wag your finger.\n  //\n  // See https://stackoverflow.com/a/48495509/56817 for more explanation.\n  const proxy = new Proxy(\n    {\n      // this is handy for testing, but probably shouldn't be used for anything\n      // else\n      wrappedContract: contract\n    },\n    {\n      get(target, key) {\n        if (key in target) return target[key];\n        if (!txManager || !nonConstantFns[key]) return contract[key];\n\n        return (...args) => {\n          const lastArg = args[args.length - 1];\n\n          // If the last arg is a business object, don't count it as a function input\n          const functionInputsLength =\n            typeof lastArg === 'object' &&\n            lastArg !== null &&\n            lastArg.constructor === Object\n              ? args.length - 1\n              : args.length;\n\n          for (const fnKey in contract.interface.functions) {\n            // Match the function overload with key that has the same number of inputs\n            if (\n              contract.interface.functions[fnKey].name === key &&\n              contract.interface.functions[fnKey].inputs.length ===\n                functionInputsLength\n            ) {\n              key = fnKey;\n            }\n          }\n          return txManager.sendContractCall(contract, key, args, name);\n        };\n      },\n\n      set(target, key, value) {\n        contract[key] = value;\n        return true;\n      }\n    }\n  );\n\n  return proxy;\n}\n",
        "import { LocalService } from '@makerdao/services-core';\n\nexport default class TimerService extends LocalService {\n  constructor(name = 'timer') {\n    super(name);\n    this._timers = {};\n  }\n\n  createTimer(name, duration, repeating, callback) {\n    this.disposeTimer(name);\n    this._timers[name] = {\n      repeating,\n      id: (repeating ? setInterval : setTimeout)(callback, duration)\n    };\n  }\n\n  disposeTimer(name) {\n    if (this._timers.hasOwnProperty(name)) {\n      let timer = this._timers[name];\n      (timer.repeating ? clearInterval : clearTimeout)(timer.id);\n    }\n  }\n\n  disposeAllTimers() {\n    for (let name of this.listTimers()) {\n      this.disposeTimer(name);\n    }\n  }\n\n  listTimers() {\n    return Object.keys(this._timers);\n  }\n}\n",
        "const enums = {\n  initialized: 'initialized',\n  pending: 'pending',\n  mined: 'mined',\n  error: 'error',\n  finalized: 'finalized'\n};\nexport default enums;\n",
        "import transactionStatus from '../eth/TransactionState';\n\nconst TransactionType = {\n  oasis: 'oasis',\n  transaction: 'transaction'\n};\n\nconst transactionLifeCycle = {\n  initialized: [transactionStatus.pending, transactionStatus.error],\n  pending: [transactionStatus.error, transactionStatus.mined],\n  mined: [transactionStatus.finalized, transactionStatus.error],\n  finalized: [],\n  error: []\n};\n\nconst transactionTypeTransitions = {\n  transaction: transactionLifeCycle\n};\n\nexport { TransactionType as default, transactionTypeTransitions };\n",
        "import { StateMachine } from '@makerdao/services-core';\nimport transactionState from '../eth/TransactionState';\nimport TransactionType, {\n  transactionTypeTransitions\n} from './TransactionTransitions';\n\nconst { initialized, pending, mined, finalized, error } = transactionState;\nconst stateOrder = [initialized, pending, mined, finalized];\n\nclass TransactionLifeCycle {\n  constructor(businessObject) {\n    this._state = new StateMachine(\n      initialized,\n      transactionTypeTransitions[TransactionType.transaction]\n    );\n    this._businessObject = businessObject;\n  }\n\n  setPending() {\n    this._state.transitionTo(pending);\n  }\n\n  setMined() {\n    this._state.transitionTo(mined);\n  }\n\n  setFinalized() {\n    this._state.transitionTo(finalized);\n  }\n\n  setError(errorObject) {\n    this.error = errorObject;\n    this._state.transitionTo(error);\n  }\n\n  state() {\n    return this._state.state();\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isInitialized() {\n    return this._state.inState(initialized);\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isPending() {\n    return this._state.inState(pending);\n  }\n\n  /**\n   * @returns {boolean|null}\n   */\n  isMined() {\n    return this._state.inState(mined);\n  }\n\n  /**\n   * @returns {boolean|null}\n   */\n  isFinalized() {\n    return this._state.inState(finalized);\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isError() {\n    return this._state.inState(error);\n  }\n\n  _returnValue() {\n    return this._businessObject || this;\n  }\n\n  inOrPastState(state) {\n    const currentState = this.state();\n    if (state === currentState) return true;\n\n    // \"error\" is not part of the state order sequence, we can check it separately\n    if (state === error) return this.isError();\n\n    const currentIndex = stateOrder.indexOf(currentState);\n    const targetIndex = stateOrder.indexOf(state);\n    if (currentIndex === -1 || targetIndex === -1) {\n      throw new Error('invalid state');\n    }\n    return currentIndex >= targetIndex;\n  }\n\n  _onStateChange(from, to, handler) {\n    this._state.onStateChanged((oldState, newState) => {\n      if (oldState === from && newState === to) {\n        handler(this._returnValue());\n      }\n    });\n  }\n\n  onPending(handler) {\n    return this._onStateChange(initialized, pending, handler);\n  }\n\n  onMined(handler) {\n    return this._onStateChange(pending, mined, handler);\n  }\n\n  onFinalized(handler) {\n    return this._onStateChange(mined, finalized, handler);\n  }\n\n  // alias for onFinalized\n  onConfirmed(handler) {\n    return this.onFinalized(handler);\n  }\n\n  onError(handler) {\n    this._state.onStateChanged((oldState, newState) => {\n      if (newState === error) {\n        handler(this.error, this._returnValue());\n      }\n    });\n  }\n\n  on(state, handler) {\n    if (state === error) return this.onError(handler);\n    if (!Object.keys(transactionState).includes(state)) {\n      throw new Error(`Unrecognized state \"${state}\"`);\n    }\n    const prevState = stateOrder[stateOrder.indexOf(state) - 1];\n    return this._onStateChange(prevState, state, handler);\n  }\n}\n\nexport default TransactionLifeCycle;\n",
        "import { promiseWait } from '../utils';\nimport TransactionLifeCycle from '../eth/TransactionLifeCycle';\nimport debug from 'debug';\nimport { ETH } from './Currency';\n\nconst log = debug('dai:TransactionObject');\n\nexport default class TransactionObject extends TransactionLifeCycle {\n  constructor(\n    transaction,\n    transactionManager,\n    { businessObject, metadata } = {}\n  ) {\n    super(businessObject);\n    this._transaction = transaction;\n    this._web3Service = transactionManager.get('web3');\n    this._nonceService = transactionManager.get('nonce');\n    this._timeStampSubmitted = new Date();\n    this.metadata = metadata || {};\n    this._confirmedBlockCount = this._web3Service.confirmedBlockCount();\n  }\n\n  timeStampSubmitted() {\n    return this._timeStampSubmitted;\n  }\n\n  timeStamp() {\n    return this._timeStampMined;\n  }\n\n  fees() {\n    return this._fees;\n  }\n\n  mine() {\n    if (!this._dataPromise) this._dataPromise = this._getTransactionData();\n    return this._dataPromise.then(() => this._returnValue());\n  }\n\n  isFinalized() {\n    if (\n      this._blockNumberWhenMined + this._confirmedBlockCount <=\n      this._web3Service.blockNumber()\n    )\n      this.setFinalized();\n    return super.isFinalized();\n  }\n\n  async confirm(count = this._confirmedBlockCount) {\n    this._confirmedBlockCount = count;\n    await this.mine();\n    if (parseInt(count) <= 0) return;\n    const newBlockNumber = this.receipt.blockNumber + count;\n    await this._web3Service.waitForBlockNumber(newBlockNumber);\n    const newReceipt = await this._web3Service.getTransactionReceipt(this.hash);\n    if (newReceipt.blockHash !== this.receipt.blockHash) {\n      throw new Error('transaction block hash changed');\n    }\n    this.setFinalized();\n    return this._returnValue();\n  }\n\n  async _getTransactionData() {\n    try {\n      let gasPrice, tx;\n      this.hash = await this._transaction;\n      if (this.hash.hash) {\n        // When using websockets, the transaction hash is returned from this._transaction\n        // Otherwise, the tx receipt is returned. This corrects in such cases\n        this.hash = this.hash.hash;\n      }\n      this.setPending(); // set state to pending\n\n      // when you're on a local testnet, the transaction will probably already\n      // be mined by this point. but on other nets, you still have to wait for\n      // it to be mined.\n      if (!tx || !tx.blockHash) {\n        tx = await this._keepWaitingForTx();\n      }\n\n      gasPrice = tx.gasPrice;\n      this._timeStampMined = new Date();\n      this._blockNumberWhenMined = tx.blockNumber;\n      this.receipt = await this._waitForReceipt();\n      if (!!this.receipt.gasUsed && !!gasPrice) {\n        this._fees = ETH.wei(gasPrice).times(this.receipt.gasUsed);\n      } else {\n        /*\n          console.warn('Unable to calculate transaction fee. Gas usage or price is unavailable. Usage = ',\n            receipt.gasUsed ? receipt.gasUsed.toString() : '<not set>',\n            'Price = ', gasPrice ? gasPrice.toString() : '<not set>'\n          );\n        */\n      }\n      if (this.receipt.status == '0x1' || this.receipt.status == 1) {\n        this.setMined();\n      } else {\n        const label = this.metadata.contract\n          ? `${this.metadata.contract}.${this.metadata.method}`\n          : 'transaction';\n        const revertMsg = `${label} ${this.hash} reverted`;\n        log(revertMsg + '\\n' + JSON.stringify(this.receipt, null, '  '));\n        throw new Error(revertMsg);\n      }\n    } catch (err) {\n      await this._nonceService.setCounts();\n      this.setError(err);\n      throw err;\n    }\n    return this;\n  }\n\n  _waitForReceipt(retries = 15, currentTry = 1) {\n    const result = Promise.resolve(\n      this._web3Service.getTransactionReceipt(this.hash)\n    );\n\n    if (retries < 1) return result;\n    return result.then(receipt => {\n      if (receipt) return receipt;\n\n      log(`Receipt is null. Retrying ${retries} more time(s)`);\n      return promiseWait(currentTry * 1500).then(() =>\n        this._waitForReceipt(retries - 1, currentTry + 1)\n      );\n    });\n  }\n\n  async _keepWaitingForTx() {\n    let tx;\n    const startTime = new Date();\n    log(`waiting for transaction ${this.hash.substring(8)}... to mine`);\n    for (let i = 0; i < 720; i++) {\n      // 1 hour max\n      tx = await this._web3Service.getTransaction(this.hash);\n      if ((tx || {}).blockHash) break;\n      log('not mined yet');\n      await promiseWait(5000);\n    }\n\n    if (tx && !tx.blockHash) {\n      throw new Error(\n        'This transaction is taking longer than it should. Check its status on etherscan or try again. Tx hash:',\n        this.hash\n      );\n    }\n\n    const elapsed = (new Date() - startTime) / 1000;\n    log(\n      `mined ${this.metadata.contract}.${this.metadata.method} with nonce ${\n        tx.nonce\n      } ${this.hash.substring(8)}... done in ${elapsed}s`\n    );\n    return tx;\n  }\n}\n",
        "import { PublicService } from '@makerdao/services-core';\nimport TransactionObject from './TransactionObject';\nimport { uniqueId } from '../utils';\nimport { each, has } from 'lodash';\nimport { inspect } from 'util';\nimport debug from 'debug';\nconst log = debug('dai:TransactionManager');\n\nexport default class TransactionManager extends PublicService {\n  constructor(name = 'transactionManager') {\n    super(name, ['web3', 'nonce', 'proxy', 'gas']);\n    this._newTxListeners = [];\n    this._tracker = new Tracker();\n  }\n\n  // this method must not be async\n  sendContractCall(contract, method, args, name) {\n    log(`sendContractCall: ${name}.${method} ${inspect(args)}`);\n    if (!args) args = [];\n    let options,\n      promise,\n      businessObject,\n      metadata = {\n        contract: name,\n        method: method.replace(/\\(.*\\)$/g, ''),\n        args\n      },\n      lastArg = args[args.length - 1];\n\n    if (typeof lastArg === 'object' && lastArg.constructor === Object) {\n      options = lastArg;\n      args = args.slice(0, args.length - 1);\n\n      // append additional metadata to the default values.\n      if (options.metadata) {\n        metadata = { ...metadata, ...options.metadata };\n        delete options.metadata;\n      }\n\n      if (has(options, 'promise')) {\n        if (options.promise) promise = options.promise;\n        delete options.promise;\n      }\n\n      if (options.businessObject) {\n        businessObject = options.businessObject;\n        delete options.businessObject;\n      }\n\n      // some subproviders require a value key included with the Tx\n      if (!has(options, 'value')) {\n        options.value = 0;\n      }\n    } else {\n      options = {};\n    }\n\n    // for promise tracking to work, we must return to the caller the result of\n    // _createTransactionObject, because that promise is the one stored for\n    // lookup to attach lifecycle hooks.\n    return this._createTransactionObject(\n      (async () => {\n        // so we do our async operations inside this immediately-executed\n        // async function.\n        const txOptions = await this._buildTransactionOptions(\n          options,\n          contract,\n          method,\n          args\n        );\n        return this._execute(contract, method, args, txOptions);\n      })(),\n      {\n        businessObject,\n        metadata,\n        promise\n      }\n    );\n  }\n\n  // this method must not be async\n  sendTransaction(options, metadata) {\n    return this._createTransactionObject(\n      (async () => {\n        const txOptions = await this._buildTransactionOptions(options);\n        return this.get('web3').sendTransaction(txOptions);\n      })(),\n      metadata\n    );\n  }\n\n  onNewTransaction(cb) {\n    this._newTxListeners.push(cb);\n  }\n\n  onTransactionUpdate(cb) {\n    this._tracker._globalListeners.push(cb);\n    return {\n      unsub: () => {\n        const idx = this._tracker._globalListeners.indexOf(cb);\n        if (idx !== -1) this._tracker._globalListeners.splice(idx, 1);\n      }\n    };\n  }\n\n  getTransaction(promise, label) {\n    return this._tracker.get(uniqueId(promise), label);\n  }\n\n  async confirm(promise, count) {\n    await promise;\n    const txs = this._tracker.getAll(uniqueId(promise));\n    return Promise.all(txs.map(tx => tx.confirm(count)));\n  }\n\n  isMined(promise) {\n    return this._tracker.get(uniqueId(promise)).isMined();\n  }\n\n  listen(promise, handlers) {\n    if (typeof handlers === 'function') {\n      this._tracker.listen(uniqueId(promise), {\n        pending: tx => handlers(tx, 'pending'),\n        mined: tx => handlers(tx, 'mined'),\n        confirmed: tx => handlers(tx, 'confirmed'),\n        error: (tx, err) => handlers(tx, 'error', err)\n      });\n    } else {\n      this._tracker.listen(uniqueId(promise), handlers);\n    }\n  }\n\n  // if options.dsProxy is set, execute this contract method through the\n  // proxy contract at that address.\n  _execute(contract, method, args, options) {\n    if (!options.dsProxy) return contract[method](...args, options);\n\n    let address;\n    if (typeof options.dsProxy === 'string') {\n      address = options.dsProxy;\n    }\n\n    delete options.dsProxy;\n    return this.get('proxy').execute(contract, method, args, options, address);\n  }\n\n  _createTransactionObject(tx, { businessObject, metadata, promise } = {}) {\n    const txo = new TransactionObject(tx, this, {\n      businessObject,\n      metadata\n    });\n\n    this._newTxListeners.forEach(cb => cb(txo));\n\n    const minePromise = txo.mine();\n\n    // we store the transaction object under the unique id of its own mine\n    // promise, so that it can be looked up when calling a contract function\n    // directly from a service method, e.g. WethToken.deposit.\n    this._tracker.store(uniqueId(minePromise), txo);\n\n    // if the `promise` object is defined in the options argument, we also store\n    // the transaction object under that promise's id, so that it can be looked\n    // up when calling a contract function indirectly via two or more nested\n    // service method calls, e.g.\n    // EthereumCdpService.lockEth -> WethToken.deposit.\n    if (promise)\n      this._tracker.store(uniqueId(promise), txo, {\n        globalTxStateUpdates: false\n      });\n\n    return minePromise;\n  }\n\n  async _buildTransactionOptions(options, contract, method, args) {\n    if (contract && !options.gasLimit) {\n      options.gasLimit = await this._getGasLimit(\n        options,\n        contract,\n        method,\n        args\n      );\n    }\n\n    if (!this.get('gas').disablePrice) {\n      let txSpeed = options.transactionSpeed;\n      options.gasPrice = await this.get('gas').getGasPrice(txSpeed);\n    }\n\n    return {\n      ...options,\n      ...this.get('web3').transactionSettings(),\n      nonce: await this.get('nonce').getNonce()\n    };\n  }\n\n  async _getGasLimit(options, contract, method, args) {\n    let transaction = {};\n    let data = contract.interface.encodeFunctionData(method, args);\n    let proxyAddress;\n\n    if (options.dsProxy) {\n      proxyAddress = await this.get('proxy').currentProxy();\n      const proxy = this.get('proxy').getUnwrappedProxyContract(proxyAddress);\n      data = proxy.interface.encodeFunctionData('execute(address,bytes)', [\n        contract.address,\n        data\n      ]);\n    }\n\n    if (options.value) {\n      transaction.value = options.value;\n    }\n\n    transaction = {\n      from: this.get('web3').currentAddress(),\n      to: options.dsProxy ? proxyAddress : contract.address,\n      data,\n      ...transaction\n    };\n\n    return this.get('gas').estimateGasLimit(transaction);\n  }\n}\n\nclass Tracker {\n  static states = ['initialized', 'pending', 'mined', 'finalized', 'error'];\n\n  constructor() {\n    this._listeners = {};\n    this._globalListeners = [];\n    this._transactions = {};\n  }\n\n  store(key, tx, options = { globalTxStateUpdates: true }) {\n    this._init(key);\n    this._transactions[key].push(tx);\n\n    for (let state of this.constructor.states) {\n      tx.on(state, () => {\n        if (options.globalTxStateUpdates) {\n          this._globalListeners.forEach(cb =>\n            tx.error ? cb(tx, state, tx.error) : cb(tx, state)\n          );\n        }\n        this._listeners[key][state].forEach(cb =>\n          tx.error ? cb(tx, tx.error) : cb(tx)\n        );\n      });\n    }\n\n    if (options.globalTxStateUpdates)\n      this._globalListeners.forEach(cb => cb(tx, 'initialized'));\n\n    this._listeners[key].initialized.forEach(cb =>\n      tx.error ? cb(tx, tx.error) : cb(tx)\n    );\n    this.clearExpiredTransactions();\n  }\n\n  listen(key, handlers) {\n    this._init(key);\n\n    for (let state in handlers) {\n      const cb = handlers[state];\n      if (state === 'confirmed') state = 'finalized';\n      this._listeners[key][state].push(cb);\n\n      // if event has already happened, call handler immediately\n      this._transactions[key].forEach(\n        tx =>\n          tx &&\n          tx.inOrPastState(state) &&\n          (tx.error ? cb(tx, tx.error) : cb(tx))\n      );\n    }\n  }\n\n  getAll(key) {\n    return this._transactions[key];\n  }\n\n  get(key) {\n    const txs = this._transactions[key];\n    if (!txs || txs.length === 0) {\n      throw new Error(`No transactions for key ${key}`);\n    }\n    if (txs.length > 1) {\n      console.warn(\n        `Key ${key} matches ${txs.length} transactions; returning the first.`\n      );\n    }\n    return txs[0];\n  }\n\n  clearExpiredTransactions() {\n    each(this._transactions, (txList, key) => {\n      txList.forEach(tx => {\n        const txAge =\n          (new Date().getTime() - new Date(tx._timeStampMined).getTime()) /\n          60000;\n        if ((tx.isError() || tx.isFinalized()) && txAge > 5) {\n          const indexToRemove = this._transactions[key].indexOf(tx);\n          this._transactions[key].splice(indexToRemove, 1);\n          if (this._transactions[key].length === 0) {\n            delete this._transactions[key];\n            delete this._listeners[key];\n          }\n        }\n      });\n    });\n  }\n\n  _init(key) {\n    if (!this._transactions[key]) this._transactions[key] = [];\n    if (!this._listeners[key]) {\n      this._listeners[key] = this.constructor.states.reduce((acc, state) => {\n        acc[state] = [];\n        return acc;\n      }, {});\n    }\n  }\n}\n",
        "class Web3ServiceList {\n  constructor() {\n    this._list = [];\n  }\n\n  push(service) {\n    //put a warning if this list is length 2 or more\n    this._list.push(service);\n  }\n\n  disconnectAll() {\n    return Promise.all(this._list, s => s.manager()._disconnect()).then(\n      () => (this._list = [])\n    );\n  }\n}\n\n// eslint-disable-next-line\nconst l = new Web3ServiceList();\nexport default l;\n",
        "import { PrivateService } from '@makerdao/services-core';\nimport { promisify, getNetworkName } from '../utils';\nimport Web3ServiceList from '../utils/Web3ServiceList';\nimport Web3 from 'web3';\nimport makeSigner from './web3/ShimEthersSigner';\nimport { last } from 'lodash';\nimport assert from 'assert';\nimport debug from 'debug';\nconst log = debug('dai:Web3Service');\n\nexport default class Web3Service extends PrivateService {\n  _blockListeners;\n  _info;\n  _ethersSigner;\n  _web3;\n  _transactionSettings;\n  _confirmedBlockCount;\n  _defaultEmitter;\n  eth;\n  _pollingInterval;\n  _networkId;\n  _currentBlockId;\n  _currentBlock;\n  _newBlocksSubscription;\n  _updateBlocksInterval;\n\n  constructor(name = 'web3') {\n    super(name, ['accounts', 'timer', 'cache', 'event']);\n\n    this._blockListeners = {};\n    this._info = {};\n    Web3ServiceList.push(this);\n  }\n\n  currentAddress() {\n    return this.get('accounts').currentAddress();\n  }\n\n  getEthersSigner() {\n    if (!this._ethersSigner) this._ethersSigner = makeSigner(this);\n    return this._ethersSigner;\n  }\n\n  web3Provider() {\n    return this._web3.currentProvider;\n  }\n\n  transactionSettings() {\n    return this._transactionSettings;\n  }\n\n  confirmedBlockCount() {\n    return this._confirmedBlockCount;\n  }\n\n  web3Contract(abi, address) {\n    return new this._web3.eth.Contract(abi, address);\n  }\n\n  initialize(settings) {\n    log('initializing...');\n    this._defaultEmitter = this.get('event');\n\n    this._web3 = new Web3();\n    this._web3.setProvider(this.get('accounts').getProvider());\n\n    this.eth = new Proxy(this, {\n      get(target, key) {\n        if (typeof key === 'string')\n          console.warn(`use .${key} instead of .eth.${key}`);\n        return target[key];\n      }\n    });\n\n    this.manager().onDisconnected(() => this._stopListeningForNewBlocks());\n    this._defaultEmitter.emit('web3/INITIALIZED', {\n      provider: settings.provider\n    });\n    this._transactionSettings = settings.transactionSettings;\n    this._confirmedBlockCount = settings.confirmedBlockCount || 5;\n    this._pollingInterval = settings.pollingInterval || 4000;\n  }\n\n  subscribe(...args) {\n    return this._web3.eth.subscribe(...args);\n  }\n\n  estimateGas(...args) {\n    return this._web3.eth.estimateGas(...args);\n  }\n\n  wait(...args) {\n    return this._web3.eth.wait(...args);\n  }\n\n  getBalance(...args) {\n    return this._web3.eth.getBalance(...args);\n  }\n\n  getAccounts(...args) {\n    return this._web3.eth.getAccounts(...args);\n  }\n\n  getBlock(...args) {\n    return this._web3.eth.getBlock(...args);\n  }\n\n  getPastLogs(...args) {\n    return this._web3.eth.getPastLogs(...args);\n  }\n\n  getStorageAt(...args) {\n    return this._web3.eth.getStorageAt(...args);\n  }\n\n  getTransaction(...args) {\n    return this._web3.eth.getTransaction(...args);\n  }\n\n  getTransactionReceipt(...args) {\n    return this._web3.eth.getTransactionReceipt(...args);\n  }\n\n  async connect() {\n    log('connecting...');\n\n    this._networkId = parseInt(await promisify(this._web3.eth.net.getId)());\n    this._currentBlock = await this._web3.eth.getBlockNumber();\n    this._updateBlockNumber(this._currentBlock);\n    this._listenForNewBlocks();\n\n    this.onNewBlock(this.get('event').ping);\n    this._defaultEmitter.emit('web3/CONNECTED', {\n      ...this._info\n    });\n  }\n\n  async authenticate() {\n    log('authenticating...');\n\n    this._defaultEmitter.emit('web3/AUTHENTICATED', {\n      account: this.currentAddress()\n    });\n  }\n\n  /*\n    sendTransaction in web3 1.0 behaves differently from its counterpart in\n    0.2x.x. it doesn't resolve until the transaction has a receipt, and throws an\n    error if the receipt indicates that the transaction was reverted.\n    the setup below emulates the old behavior, because TransactionObject still\n    expects it. if there is an error due to the transaction being reverted, it\n    will be ignored, because the promise will have already resolved.\n\n    this can (and should) be refactored when we drop support for HTTP providers.\n\n    https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsendtransaction\n    https://web3js.readthedocs.io/en/1.0/web3-eth.html#sendtransaction\n  */\n  sendTransaction(...args) {\n    return new Promise((resolve, reject) => {\n      this._web3.eth\n        .sendTransaction(...args)\n        .on('transactionHash', tx => {\n          return resolve({\n            hash: tx,\n            // ethers TransactionResponse expects a wait method\n            wait: () => {}\n          });\n        })\n        .on('error', reject);\n    });\n  }\n\n  networkId() {\n    console.warn('.networkId() is deprecated; use .network instead');\n    return this.network;\n  }\n\n  get network() {\n    assert(this._networkId, 'Cannot resolve network ID. Are you connected?');\n    return this._networkId;\n  }\n\n  get networkName() {\n    return getNetworkName(this.network);\n  }\n\n  get rpcUrl() {\n    const provider = last(this._web3.currentProvider._providers);\n    return (provider as any).rpcUrl || (provider as any)._url || null;\n  }\n\n  blockNumber() {\n    return this._currentBlock;\n  }\n\n  onNewBlock(callback) {\n    if (!this._blockListeners['*']) {\n      this._blockListeners['*'] = [];\n    }\n\n    this._blockListeners['*'].push(callback);\n  }\n\n  async waitForBlockNumber(blockNumber) {\n    if (blockNumber < this._currentBlock) {\n      console.error('Attempted to wait for past block ' + blockNumber);\n      return;\n    }\n\n    if (blockNumber === this._currentBlock) {\n      return Promise.resolve(blockNumber);\n    }\n\n    if (!this._blockListeners[blockNumber]) {\n      this._blockListeners[blockNumber] = [];\n    }\n\n    return new Promise(resolve => {\n      this._blockListeners[blockNumber].push(resolve);\n    });\n  }\n\n  _listenForNewBlocks() {\n    if (this.networkName !== 'test') {\n      log('Using newBlockHeaders subscription for block detection');\n      this._newBlocksSubscription = this.subscribe('newBlockHeaders').on(\n        'data',\n        ({ number: blockNumber }) => {\n          if (!this._currentBlock) this._currentBlock = blockNumber - 1;\n          for (let i = this._currentBlock + 1; i <= blockNumber; i++) {\n            this._updateBlockNumber(i);\n          }\n        }\n      );\n    } else {\n      log('Using manual getBlockNumber polling for block detection');\n      const updateBlocks = async () => {\n        const blockNumber = await this._web3.eth.getBlockNumber();\n        if (!this._currentBlock) this._currentBlock = blockNumber - 1;\n        for (let i = this._currentBlock + 1; i <= blockNumber; i++) {\n          this._updateBlockNumber(i);\n        }\n      };\n      this._updateBlocksInterval = setInterval(\n        updateBlocks,\n        this._pollingInterval\n      );\n    }\n  }\n\n  _updateBlockNumber(blockNumber) {\n    log(`Latest block: ${blockNumber}`);\n\n    this._currentBlock = blockNumber;\n    if (this._blockListeners[blockNumber]) {\n      this._blockListeners[blockNumber].forEach(c => c(blockNumber));\n      this._blockListeners[blockNumber] = undefined;\n    }\n\n    if (this._blockListeners['*']) {\n      this._blockListeners['*'].forEach(c => c(blockNumber));\n    }\n  }\n\n  _stopListeningForNewBlocks() {\n    if (this._newBlocksSubscription) {\n      this._newBlocksSubscription.unsubscribe(err => {\n        if (err) throw err;\n      });\n    } else if (this._updateBlocksInterval) {\n      clearInterval(this._updateBlocksInterval);\n    }\n  }\n}\n",
        "// A simple Ethers Signer built directly from a Web3 provider.\n\nimport { promisify } from '../../utils';\n\nexport default function makeSigner(web3Service) {\n  const provider = web3Service.web3Provider();\n  const call = promisify(web3Service._web3.eth.call);\n  return {\n    getAddress: () => web3Service.currentAddress(),\n    estimateGas: tx => web3Service.estimateGas(tx),\n    sendTransaction: tx => {\n      return web3Service.sendTransaction({\n        ...tx,\n        from: web3Service.currentAddress()\n      });\n    },\n    call,\n    isSigner: () => true,\n    _isSigner: true,\n    provider: new Proxy(provider, {\n      get(target, key) {\n        switch (key) {\n          case 'resolveName':\n            return address => address;\n          case '_isProvider':\n            return true;\n          case 'call':\n            return call;\n          default:\n            return target[key];\n        }\n      }\n    })\n  };\n}\n",
        "import { merge } from 'lodash';\nimport { standardizeConfig } from '@makerdao/services-core';\n\nexport function mergeServiceConfig(role, sink, source, resolver) {\n  sink = standardizeConfig(role, sink, resolver);\n  source = standardizeConfig(role, source);\n  if (sink[0] === false || source[0] === false) return source;\n\n  return [\n    typeof source[0] != 'boolean' ? source[0] : sink[0],\n    merge({}, sink[1], source[1])\n  ];\n}\n\nexport function getSettings(config) {\n  if (config instanceof Array) return config[1];\n  return config;\n}\n",
        "import { ServiceProvider } from '@makerdao/services-core';\nimport AccountsService from '../eth/AccountsService';\nimport AllowanceService from '../eth/AllowanceService';\nimport CacheService from '../utils/CacheService';\nimport DSProxyService from '../eth/DSProxyService';\nimport EthereumTokenService from '../eth/EthereumTokenService';\nimport EventService from '../utils/events/EventService';\nimport GasService from '../eth/GasService';\nimport MulticallService from '../eth/MulticallService';\nimport NonceService from '../eth/NonceService';\nimport NullEventService from '../utils/events/NullEventService';\nimport SmartContractService from '../eth/SmartContractService';\nimport TimerService from '../utils/TimerService';\nimport TransactionManager from '../eth/TransactionManager';\nimport Web3Service from '../eth/Web3Service';\nimport { getSettings } from './index';\n\nexport const resolver = {\n  defaults: {\n    accounts: 'AccountsService',\n    allowance: 'AllowanceService',\n    cache: 'CacheService',\n    event: 'EventService',\n    gas: 'GasService',\n    multicall: 'MulticallService',\n    nonce: 'NonceService',\n    proxy: 'DSProxyService',\n    smartContract: 'SmartContractService',\n    timer: 'TimerService',\n    token: 'EthereumTokenService',\n    transactionManager: 'TransactionManager',\n    web3: 'Web3Service'\n  },\n  disabled: {\n    event: 'NullEventService'\n  }\n};\n\nexport default class DefaultServiceProvider extends ServiceProvider {\n  constructor(config: any = {}) {\n    if (config.web3) {\n      config = {\n        ...config,\n        accounts: {\n          ...config.accounts,\n          web3: getSettings(config.web3)\n        }\n      };\n    }\n\n    super(config, {\n      services: {\n        AccountsService,\n        AllowanceService,\n        CacheService,\n        DSProxyService,\n        EthereumTokenService,\n        EventService,\n        GasService,\n        MulticallService,\n        NonceService,\n        NullEventService,\n        SmartContractService,\n        TimerService,\n        TransactionManager,\n        Web3Service\n      },\n      ...resolver\n    });\n  }\n}\n",
        "import test from './presets/test.json';\nimport kovan from './presets/kovan.json';\nimport goerli from './presets/goerli.json';\nimport http from './presets/http.json';\nimport ws from './presets/ws.json';\nimport mainnet from './presets/mainnet.json';\nimport browser from './presets/browser.json';\nimport inject from './presets/inject.json';\n\nimport { merge, intersection } from 'lodash';\nimport { mergeServiceConfig } from './index';\nimport { AccountType } from '../utils/constants';\n\nclass ConfigPresetNotFoundError extends Error {\n  constructor(message) {\n    super('Cannot find configuration preset with name: ' + message);\n  }\n}\n\nconst serviceRoles = [\n  'accounts',\n  'allowance',\n  'gas',\n  'multicall',\n  'nonce',\n  'proxy',\n  'smartContract',\n  'timer',\n  'token',\n  'transactionManager',\n  'web3'\n];\n\nfunction loadPreset(name) {\n  if (typeof name == 'object') {\n    return name; // for testing\n  }\n\n  let preset;\n  switch (name) {\n    case 'test':\n      preset = test;\n      break;\n    case 'http':\n      preset = http;\n      break;\n    case 'ws':\n    case 'websocket':\n      preset = ws;\n      break;\n    case 'kovan':\n      preset = kovan;\n      break;\n    case 'goerli':\n      preset = goerli;\n      break;\n    case 'mainnet':\n      preset = mainnet;\n      break;\n    case 'browser':\n      preset = browser;\n      break;\n    case 'inject':\n      preset = inject;\n      break;\n    default:\n      throw new ConfigPresetNotFoundError(name);\n  }\n  // make a copy so we don't overwrite the original values\n  return merge({}, preset);\n}\n\nconst reservedWords = [\n  'accounts',\n  'overrideMetamask',\n  'plugins',\n  'privateKey',\n  'provider',\n  'url'\n];\n\nfunction checkForReservedWords(words) {\n  const usedReservedWords = intersection(words, reservedWords);\n  if (usedReservedWords.length > 0) {\n    throw new Error(\n      'The following words cannot be used as service role names: ' +\n        usedReservedWords.join(', ')\n    );\n  }\n}\n\n/**\n * @param {string} preset\n * @param {object} options\n */\n\nfunction createConfig(preset, options = {}, resolver) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = options.preset;\n  }\n\n  const config = loadPreset(preset);\n  const additionalServices = options.additionalServices || [];\n  checkForReservedWords(additionalServices);\n\n  for (let role of serviceRoles.concat(additionalServices)) {\n    if (!(role in options)) continue;\n    if (!(role in config)) {\n      config[role] = options[role];\n      continue;\n    }\n    config[role] = mergeServiceConfig(\n      role,\n      config[role],\n      options[role],\n      resolver\n    );\n  }\n\n  // web3-specific convenience options\n  if (config.web3) {\n    const web3Settings = config.web3[1] || config.web3;\n    if (!web3Settings.provider) web3Settings.provider = {};\n\n    if (options.url) {\n      web3Settings.provider.url = options.url;\n    }\n\n    if (options.provider) {\n      merge(web3Settings.provider, options.provider);\n    }\n  }\n\n  // accounts-specific convenience option\n  if (options.privateKey) {\n    config.accounts = {\n      ...config.accounts,\n      default: { type: AccountType.PRIVATE_KEY, key: options.privateKey }\n    };\n  }\n\n  return config;\n}\n\nexport default {\n  createConfig\n};\n",
        "import DefaultServiceProvider, {\n  resolver\n} from './config/DefaultServiceProvider';\nimport ConfigFactory from './config/ConfigFactory';\nimport { mergeWith, cloneDeep, uniq, has } from 'lodash';\n\nimport { strict as assert } from 'assert';\n\n// a plugin must be either an object with at least one of these keys defined, or\n// a single function, which will be treated as the value for `afterCreate`.\nconst PLUGIN_KEYS = ['beforeCreate', 'afterCreate', 'addConfig'];\n\n/**\n * do not call `new Maker()` directly; use `Maker.create` instead\n */\nexport class MakerClass {\n  _container: any;\n  _authenticatedPromise: Promise<any>;\n  currencies: any;\n  QueryApi: any;\n  utils: any;\n\n  constructor(preset, options: any = {}, userOptions: any = {}) {\n    const { plugins = [], ...otherOptions } = options;\n\n    for (const [plugin, pluginOptions] of plugins) {\n      if (plugin.addConfig) {\n        mergeOptions(\n          otherOptions,\n          plugin.addConfig(otherOptions, pluginOptions)\n        );\n      }\n    }\n    // This ensures user supplied config options always take priority\n    if (plugins && userOptions) mergeOptions(otherOptions, userOptions);\n\n    const config = ConfigFactory.createConfig(preset, otherOptions, resolver);\n    this._container = new DefaultServiceProvider(config).buildContainer();\n\n    for (const [plugin, pluginOptions] of plugins) {\n      if (plugin.afterCreate) plugin.afterCreate(this, config, pluginOptions);\n    }\n\n    if (otherOptions.autoAuthenticate !== false) this.authenticate();\n  }\n\n  authenticate() {\n    if (!this._authenticatedPromise) {\n      this._authenticatedPromise = this._container.authenticate();\n    }\n    return this._authenticatedPromise;\n  }\n\n  // shorthand methods\n  addAccount(...args) {\n    return this.service('accounts').addAccount(...args);\n  }\n\n  currentAccount(...args) {\n    return this.service('accounts').currentAccount(...args);\n  }\n\n  listAccounts(...args) {\n    return this.service('accounts').listAccounts(...args);\n  }\n\n  useAccount(...args) {\n    return this.service('accounts').useAccount(...args);\n  }\n\n  useAccountWithAddress(...args) {\n    return this.service('accounts').useAccountWithAddress(...args);\n  }\n\n  currentAddress(...args) {\n    return this.service('accounts').currentAddress(...args);\n  }\n\n  on(...args) {\n    return this.service('event').on(...args);\n  }\n\n  getToken(...args) {\n    return this.service('token').getToken(...args);\n  }\n\n  currentProxy(...args) {\n    return this.service('proxy').currentProxy(...args);\n  }\n\n  watch(...args) {\n    return this.service('multicall').watch(...args);\n  }\n\n  latest(...args) {\n    return this.service('multicall').latest(...args);\n  }\n\n  openCdp() {\n    throw new Error(\n      '\"openCdp\" is no longer available here. Add @makerdao/dai-plugin-scd, then use maker.service(\\'cdp\\').openCdp'\n    );\n  }\n\n  getCdp() {\n    throw new Error(\n      '\"getCdp\" is no longer available here. Add @makerdao/dai-plugin-scd, then use maker.service(\\'cdp\\').getCdp'\n    );\n  }\n\n  getCdpIds() {\n    throw new Error(\n      '\"getCdpIds\" is no longer available here. Add @makerdao/dai-plugin-scd, then use maker.service(\\'cdp\\').getCdpIds'\n    );\n  }\n  // skipAuthCheck should only be set if you're sure you don't need the service\n  // to be initialized yet, e.g. when setting up a plugin\n  service(service, skipAuthCheck = false) {\n    const skipAuthCheckForServices = ['event'];\n    if (\n      !skipAuthCheck &&\n      !this._container.isAuthenticated &&\n      !skipAuthCheckForServices.includes(service)\n    ) {\n      throw new Error(\n        `Can't use service ${service} before authenticate() has finished.`\n      );\n    }\n    return this._container.service(service);\n  }\n}\n\nfunction mergeOptions(object, source) {\n  return mergeWith(object, source, (objValue, srcValue, key) => {\n    if (Array.isArray(objValue) && key === 'abi') return uniq(objValue);\n\n    if (Array.isArray(objValue) && key !== 'abi')\n      return uniq(objValue.concat(srcValue));\n    // when this function returns undefined, mergeWith falls back to the\n    // default merging behavior.\n    // https://devdocs.io/lodash~4/index#mergeWith\n  });\n}\n\nconst standardizePluginConfig = plugins =>\n  plugins.map((x, i) => {\n    let [plugin, pluginOptions] = Array.isArray(x) ? x : [x, {}];\n    if (typeof plugin === 'function') plugin = { afterCreate: plugin };\n\n    assert(\n      PLUGIN_KEYS.some(x => has(plugin, x)),\n      `plugins[${i}] does not seem to be a plugin`\n    );\n\n    return [plugin, pluginOptions];\n  });\n\nasync function create(...args) {\n  const [preset, options = {}] = args;\n  const { plugins, ...otherOptions } = options;\n\n  // Preserve the user supplied options to apply after plugins are executed.\n  const userOptions = cloneDeep(otherOptions);\n\n  if (plugins) {\n    options.plugins = standardizePluginConfig(plugins);\n    for (const [p, popts] of options.plugins) {\n      // the beforeCreate function can return new options to be sent to the\n      // Maker constructor\n      if (p.beforeCreate) Object.assign(options, await p.beforeCreate(popts));\n    }\n  }\n\n  const maker = new MakerClass(preset, options, userOptions);\n  if (options.autoAuthenticate !== false) await maker.authenticate();\n  return maker;\n}\n\nconst Maker = {\n  create,\n  currencies: null,\n  QueryApi: null,\n  utils: null\n};\n\nexport default Maker;\n",
        "import { BigNumber as EthersBigNumber, utils as ethersUtils } from 'ethers';\nimport BigNumber from 'bignumber.js';\nimport assert from 'assert';\n\nexport function numberToBytes32(num) {\n  const bn = EthersBigNumber.from(num);\n  return ethersUtils.hexlify(ethersUtils.zeroPad(bn, 32));\n}\n\nexport function bytes32ToNumber(bytes32) {\n  return EthersBigNumber.from(bytes32).toNumber();\n}\n\nexport function stringToBytes32(text, pad = true) {\n  var data = ethersUtils.toUtf8Bytes(text);\n  if (data.length > 32) {\n    throw new Error('too long');\n  }\n  if (pad) {\n    return ethersUtils.hexlify(ethersUtils.zeroPad(data, 32));\n  }\n  return ethersUtils.hexlify(data);\n}\n\nexport function stringToBytes(str) {\n  assert(!!str, 'argument is falsy');\n  assert(typeof str === 'string', 'argument is not a string');\n  return '0x' + Buffer.from(str).toString('hex');\n}\n\nexport function bytesToString(hex) {\n  return Buffer.from(hex.replace(/^0x/, ''), 'hex')\n    .toString()\n    .replace(/\\x00/g, ''); // eslint-disable-line no-control-regex\n}\nexport function padRight(string, chars, sign) {\n  return string + new Array(chars - string.length + 1).join(sign ? sign : '0');\n}\n\nexport function toHex(str, { with0x = true, rightPadding = 64 } = {}) {\n  let result = '';\n  for (let i = 0; i < str.length; i++) {\n    result += str.charCodeAt(i).toString(16);\n  }\n  if (rightPadding > 0) result = padRight(result, rightPadding);\n  return with0x ? '0x' + result : result;\n}\n\nexport function fromWei(value) {\n  return BigNumber(value).shiftedBy(-18);\n}\n\nexport function fromRay(value) {\n  return BigNumber(value).shiftedBy(-27);\n}\n\nexport function fromRad(value) {\n  return BigNumber(value).shiftedBy(-45);\n}\n",
        "import assert from 'assert';\nimport fetch from 'isomorphic-fetch';\n\nexport async function getQueryResponse(serverUrl, query, variables) {\n  const resp = await fetch(serverUrl, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      query,\n      variables\n    })\n  });\n\n  const { data } = await resp.json();\n  assert(data, `error fetching data from ${serverUrl}`);\n  return data;\n}\n",
        "import Maker from './Maker';\nimport { currencies } from './eth/Currency';\nimport {\n  stringToBytes32,\n  bytes32ToNumber,\n  numberToBytes32,\n  stringToBytes,\n  bytesToString,\n  padRight,\n  toHex\n} from './utils/conversion';\nimport { getQueryResponse } from './QueryApi';\nexport * from './eth/Currency';\n\nfor (let symbol in currencies) {\n  Maker[symbol] = currencies[symbol];\n}\n\nMaker.currencies = currencies;\nMaker.QueryApi = { getQueryResponse };\nMaker.utils = { stringToBytes32 };\n\nexport default Maker;\n\nexport const QueryApi = { getQueryResponse };\nexport const utils = {\n  numberToBytes32,\n  stringToBytes32,\n  bytes32ToNumber,\n  stringToBytes,\n  bytesToString,\n  padRight,\n  toHex\n};\n"
    ],
    "names": [
        "runtime",
        "exports",
        "Op",
        "Object",
        "prototype",
        "hasOwn",
        "hasOwnProperty",
        "$Symbol",
        "Symbol",
        "iteratorSymbol",
        "iterator",
        "asyncIteratorSymbol",
        "asyncIterator",
        "toStringTagSymbol",
        "toStringTag",
        "wrap",
        "innerFn",
        "outerFn",
        "self",
        "tryLocsList",
        "generator",
        "create",
        "Generator",
        "context",
        "Context",
        "_invoke",
        "state",
        "method",
        "arg",
        "Error",
        "value",
        "undefined",
        "done",
        "delegate",
        "delegateResult",
        "maybeInvokeDelegate",
        "ContinueSentinel",
        "sent",
        "_sent",
        "dispatchException",
        "abrupt",
        "record",
        "tryCatch",
        "type",
        "makeInvokeMethod",
        "fn",
        "obj",
        "call",
        "err",
        "GeneratorFunction",
        "GeneratorFunctionPrototype",
        "IteratorPrototype",
        "this",
        "getProto",
        "getPrototypeOf",
        "NativeIteratorPrototype",
        "values",
        "Gp",
        "defineIteratorMethods",
        "forEach",
        "AsyncIterator",
        "PromiseImpl",
        "previousPromise",
        "callInvokeWithMethodAndArg",
        "resolve",
        "reject",
        "invoke",
        "result",
        "__await",
        "then",
        "unwrapped",
        "error",
        "TypeError",
        "info",
        "resultName",
        "next",
        "nextLoc",
        "pushTryEntry",
        "locs",
        "entry",
        "tryLoc",
        "catchLoc",
        "finallyLoc",
        "afterLoc",
        "tryEntries",
        "push",
        "resetTryEntry",
        "completion",
        "reset",
        "iterable",
        "iteratorMethod",
        "isNaN",
        "length",
        "i",
        "doneResult",
        "constructor",
        "displayName",
        "isGeneratorFunction",
        "genFun",
        "ctor",
        "name",
        "mark",
        "setPrototypeOf",
        "__proto__",
        "awrap",
        "async",
        "Promise",
        "iter",
        "toString",
        "keys",
        "object",
        "key",
        "reverse",
        "pop",
        "skipTempReset",
        "prev",
        "charAt",
        "slice",
        "stop",
        "rootRecord",
        "rval",
        "exception",
        "handle",
        "loc",
        "caught",
        "hasCatch",
        "hasFinally",
        "finallyEntry",
        "complete",
        "finish",
        "thrown",
        "delegateYield",
        "module",
        "regeneratorRuntime",
        "accidentalStrictMode",
        "Function",
        "setupEngine",
        "settings",
        "providerSettings",
        "web3",
        "provider",
        "engine",
        "Web3ProviderEngine",
        "pollingInterval",
        "getHttpProvider",
        "rpcUrl",
        "getRpcUrl",
        "subscriptionProvider",
        "SubscriptionSubprovider",
        "on",
        "data",
        "emit",
        "addProvider",
        "RpcSource",
        "getWebsocketProvider",
        "WebsocketSubprovider",
        "getInjectedProvider",
        "inject",
        "ProviderSubprovider",
        "getBrowserProvider",
        "protocol",
        "window",
        "subprovider",
        "isWindowProvider",
        "ethereum",
        "enable",
        "currentProvider",
        "network",
        "infuraProjectId",
        "url",
        "getInfuraUrl",
        "privateKeyAccountFactory",
        "match",
        "startsWith",
        "replace",
        "keySansPrefix",
        "account",
        "Account",
        "fromPrivate",
        "keyBuffer",
        "Buffer",
        "from",
        "Wallet",
        "getAddressString",
        "address",
        "toLowerCase",
        "getPrivateKey",
        "getAccountAddress",
        "assert",
        "offset",
        "handleRequest",
        "params",
        "id",
        "val",
        "matchingAddress",
        "find",
        "a",
        "providerAccountFactory",
        "Proxy",
        "browserProviderAccountFactory",
        "UINT256_MAX",
        "log",
        "debug",
        "sanitizeAccount",
        "pick",
        "AccountsService",
        "_accounts",
        "_accountFactories",
        "privateKey",
        "browser",
        "initialize",
        "_settings",
        "omit",
        "_engine",
        "_provider",
        "connect",
        "accountNames",
        "addAccount",
        "start",
        "getProvider",
        "addAccountType",
        "factory",
        "invariant",
        "options",
        "autoSwitch",
        "otherSettings",
        "accountData",
        "_getAccountWithAddress",
        "_currentAccount",
        "useAccount",
        "hasAccount",
        "get",
        "listAccounts",
        "map",
        "selectedAddress",
        "_autoSwitchCheckHandle",
        "clearInterval",
        "getSelectedAddress",
        "setInterval",
        "_autoSwitchCheckAccountChange",
        "removeProvider",
        "currentWallet",
        "currentAccount",
        "addr",
        "activeBrowserAddress",
        "_this2",
        "useAccountWithAddress",
        "e",
        "toUpperCase",
        "hasNonProviderAccount",
        "currentAddress",
        "PublicService",
        "eth",
        "defaultAccount",
        "tracksTransactions",
        "tracksTransactionsWithOptions",
        "numArguments",
        "target",
        "descriptor",
        "original",
        "correctArgsLength",
        "args",
        "last",
        "promise",
        "_asyncToGenerator",
        "newArgs",
        "times",
        "apply",
        "_this",
        "maxAllowance",
        "BigNumber",
        "shiftedBy",
        "AllowanceService",
        "_shouldMinimizeAllowance",
        "useMinimizeAllowancePolicy",
        "requireAllowance",
        "tokenSymbol",
        "receiverAddress",
        "estimate",
        "token",
        "getToken",
        "ownerAddress",
        "allowance",
        "lt",
        "div",
        "approveUnlimited",
        "tx",
        "transaction",
        "approve",
        "removeAllowance",
        "spenderAddress",
        "parseInt",
        "PrivateService",
        "__decorate",
        "CacheService",
        "_LocalService",
        "storage",
        "_storage",
        "isEnabled",
        "has",
        "fetch",
        "store",
        "LocalService",
        "daiV1",
        "tub",
        "dappHub",
        "dsValue",
        "dsEthToken",
        "dsGuard",
        "dsChief",
        "dsSpell",
        "dsSpellBook",
        "dsProxy",
        "exchangesV1",
        "makerOtc",
        "general",
        "erc20",
        "proxies",
        "oasisProxy",
        "saiProxy",
        "dsProxyFactory",
        "proxyRegistry",
        "multicall",
        "cageFree",
        "DSProxyService",
        "_PrivateService",
        "authenticate",
        "getProxyAddress",
        "_currentProxy",
        "setSmartContractService",
        "service",
        "_smartContractService",
        "_proxyRegistry",
        "getContract",
        "_resetDefaults",
        "newProxy",
        "_currentAddress",
        "currentProxy",
        "ensureProxy",
        "proxy",
        "build",
        "txo",
        "receipt",
        "logs",
        "execute",
        "contract",
        "proxyContract",
        "getUnwrappedProxyContract",
        "encodeFunctionData",
        "providedAddress",
        "proxyAddress",
        "getOwner",
        "_getWrappedProxyContract",
        "owner",
        "setOwner",
        "newOwner",
        "getContractByAddressAndAbi",
        "abis",
        "Contract",
        "getEthersSigner",
        "MKR",
        "WETH",
        "PETH",
        "ETH",
        "SAI_PIP",
        "SAI_TUB",
        "MAKER_OTC",
        "OASIS_PROXY",
        "SAI_PROXY",
        "PROXY_REGISTRY",
        "DS_PROXY_FACTORY",
        "DS_PROXY",
        "MULTICALL",
        "SAI_CAGEFREE",
        "addressMapping",
        "mainnet",
        "kovan",
        "goerli",
        "testnet",
        "contractAddressesInfo",
        "addresses",
        "tokens",
        "SAI",
        "version",
        "abi",
        "decimals",
        "SAI_GEM",
        "SAI_SKR",
        "GOV_OLD",
        "SAI_GOV",
        "contracts",
        "contractInfo",
        "networkId",
        "currencies",
        "reduce",
        "output",
        "symbol",
        "createCurrency",
        "USD",
        "getCurrency",
        "createGetCurrency",
        "USD_ETH",
        "createCurrencyRatio",
        "USD_MKR",
        "USD_PETH",
        "USD_WETH",
        "assign",
        "Erc20Token",
        "web3Service",
        "currency",
        "_contract",
        "_web3",
        "_decimals",
        "_currency",
        "tokenOwner",
        "spender",
        "_valueFromContract",
        "balance",
        "balanceOf",
        "totalSupply",
        "_valueForContract",
        "unit",
        "_getCurrency",
        "toFixed",
        "metadata",
        "action",
        "allowing",
        "ethers",
        "Number",
        "MAX_SAFE_INTEGER",
        "unlimited",
        "transfer",
        "to",
        "amount",
        "transferFrom",
        "EtherToken",
        "gasService",
        "transactionManager",
        "_gasService",
        "_transactionManager",
        "getBalance",
        "wei",
        "toAddress",
        "fromAddress",
        "curAmt",
        "_hex",
        "sendTransaction",
        "WethToken",
        "_Erc20Token",
        "deposit",
        "withdraw",
        "PethToken",
        "_tub",
        "join",
        "exit",
        "wrapperRatio",
        "per",
        "ray",
        "joinPrice",
        "ask",
        "exitPrice",
        "bid",
        "EthereumTokenService",
        "_tokens",
        "_addedTokens",
        "_addressOverrides",
        "addressOverrides",
        "getTokens",
        "indexOf",
        "_getTokenInfo",
        "scs",
        "ERC20TokenAbi",
        "networkName",
        "tokenInfoList",
        "_getNetworkMapping",
        "tokenInfo",
        "mapping",
        "networks",
        "filter",
        "m",
        "_selectTokenVersions",
        "tokenArray",
        "versionArray",
        "promisify",
        "concat",
        "promiseWait",
        "ms",
        "setTimeout",
        "uniqueId",
        "currentId",
        "WeakMap",
        "set",
        "createPayloadFetcher",
        "payloadGetterMap",
        "all",
        "entries",
        "getter",
        "states",
        "payload",
        "createMemoizedPoll",
        "getState",
        "curr",
        "live",
        "ping",
        "isEqual",
        "heat",
        "cool",
        "EventEmitter2",
        "EventEmitterObj",
        "EventEmitter",
        "disposeSelf",
        "_emitter",
        "wildcard",
        "delimiter",
        "_polls",
        "_block",
        "_sequenceNum",
        "_disposeSelf",
        "bind",
        "event",
        "block",
        "_getBlock",
        "listeners",
        "eventObj",
        "sequence",
        "listener",
        "poll",
        "removeListener",
        "registerPollEvents",
        "eventPayloadMap",
        "eventType",
        "payloadFetcher",
        "memoizedPoll",
        "_setBlock",
        "dispose",
        "_startPolls",
        "_stopPolls",
        "EventService",
        "emitters",
        "buildEmitter",
        "defaultEmitter",
        "emitter",
        "_defaultEmitter",
        "Math",
        "random",
        "substring",
        "disposeEmitter",
        "_disposeEmitter",
        "newEmitter",
        "_logError",
        "msg",
        "GasService",
        "_fallback",
        "_multiplier",
        "_transactionSpeed",
        "_parseConfig",
        "limit",
        "price",
        "_gasStationDataPromise",
        "disablePrice",
        "fetchGasStationData",
        "label",
        "_setProperties",
        "apiKey",
        "json",
        "console",
        "getGasPrice",
        "txSpeed",
        "speedSetting",
        "transactionSpeed",
        "gasStationData",
        "utils",
        "toWei",
        "getWaitTime",
        "estimateGasLimit",
        "disableLimit",
        "fallback",
        "web3Data",
        "getBlock",
        "estimateGas",
        "blockLimit",
        "gasLimit",
        "multiplier",
        "absolute",
        "min",
        "removeMultiplier",
        "removeAbsolute",
        "_absolute",
        "removeFallback",
        "number",
        "speed",
        "validKeys",
        "includes",
        "log2",
        "throwIfErrorInValues",
        "v",
        "checkForErrors",
        "catchNestedErrors",
        "f",
        "catchError",
        "MulticallService",
        "_schemas",
        "_schemaByObservableKey",
        "_schemaInstances",
        "_subjects",
        "_observables",
        "_watcherUpdates",
        "_schemaSubscribers",
        "_totalSchemaSubscribers",
        "_totalActiveSchemas",
        "_multicallResultCache",
        "_addresses",
        "_removeSchemaTimers",
        "removeSchemaDelay",
        "debounceTime",
        "latestDebounceTime",
        "latestTimeout",
        "getContractAddresses",
        "_removeSchemaDelay",
        "_debounceTime",
        "_latestDebounceTime",
        "_latestTimeout",
        "_connectedAddress",
        "createWatcher",
        "useWeb3Provider",
        "interval",
        "config",
        "multicallAddress",
        "getContractAddress",
        "onNewBlockPolling",
        "_watcher",
        "onNewBlock",
        "blockNumber",
        "onPoll",
        "latestBlockNumber",
        "onError",
        "tap",
        "cb",
        "_flushPendingSchemaRemovals",
        "restart",
        "schemaByObservableKey",
        "registerSchemas",
        "schemas",
        "Array",
        "isArray",
        "item",
        "schema",
        "returns",
        "ret",
        "_this3",
        "latest",
        "obsPath",
        "_watch",
        "depth",
        "throwIfError",
        "pipe",
        "takeUntil",
        "timer",
        "throwIfEmpty",
        "take",
        "toPromise",
        "watch",
        "schemaDefinition",
        "expectedArgs",
        "generate",
        "throwError",
        "validate",
        "_schemaDefinition$val",
        "schemaInstance",
        "_createSchemaInstance",
        "computed",
        "existing",
        "dependencies",
        "recurseDependencyTree",
        "trie_",
        "trie",
        "indexesAtLeafNodes",
        "node",
        "allLeafNodes",
        "every",
        "_this4",
        "combineLatest",
        "idx",
        "flatMap",
        "dependencySubs",
        "observable",
        "path",
        "subject",
        "ReplaySubject",
        "_handleResult",
        "Observable",
        "observer",
        "_addSchemaToMulticall",
        "_subscribeToWatcherUpdates",
        "sub",
        "subscribe",
        "_removeSchemaFromMulticall",
        "unsubscribe",
        "instancePath",
        "transforms",
        "fullPath",
        "clearTimeout",
        "calls",
        "process",
        "_process",
        "activeSchemaIds",
        "_removeSchemaImmediately",
        "unsub",
        "_process2",
        "_this5",
        "schemaTimers",
        "_validateResult",
        "split",
        "observableKey",
        "_schemaDefinition$val3",
        "update",
        "_this6",
        "logValue",
        "_isBigNumber",
        "activeSchemas",
        "NonceService",
        "_counts",
        "_accountsService",
        "_web3Service",
        "setCounts",
        "_getTxCount",
        "getTransactionCount",
        "_compareNonceCounts",
        "txCount",
        "_removeDuplicateAddresses",
        "accounts",
        "uniqueAddresses",
        "accountsList",
        "getNonce",
        "nonce",
        "_",
        "NullEventService",
        "SmartContractService",
        "getContractByName",
        "getContractAddressByName",
        "addContracts",
        "_addedContracts",
        "acc",
        "lookupContractName",
        "signerOrProvider",
        "txManager",
        "nonConstantFns",
        "inputs",
        "canModifyState",
        "constant",
        "stateMutability",
        "methodSig",
        "wrappedContract",
        "lastArg",
        "functionInputsLength",
        "fnKey",
        "functions",
        "sendContractCall",
        "wrapContract",
        "_getContractInfo",
        "mapValues",
        "_getAllContractInfo",
        "versions",
        "findLatestContractInfo",
        "hasContract",
        "getWeb3ContractByName",
        "web3Contract",
        "findContractInfoForVersion",
        "_contractInfoCache",
        "allContractInfo",
        "getSingleAddress",
        "max",
        "addressGroup",
        "TimerService",
        "_timers",
        "createTimer",
        "duration",
        "repeating",
        "callback",
        "disposeTimer",
        "disposeAllTimers",
        "listTimers",
        "enums",
        "initialized",
        "pending",
        "mined",
        "finalized",
        "transactionTypeTransitions",
        "transactionStatus",
        "transactionState",
        "stateOrder",
        "TransactionLifeCycle",
        "businessObject",
        "_state",
        "StateMachine",
        "_businessObject",
        "setPending",
        "transitionTo",
        "setMined",
        "setFinalized",
        "setError",
        "errorObject",
        "isInitialized",
        "inState",
        "isPending",
        "isMined",
        "isFinalized",
        "isError",
        "_returnValue",
        "inOrPastState",
        "currentState",
        "currentIndex",
        "targetIndex",
        "_onStateChange",
        "handler",
        "onStateChanged",
        "oldState",
        "newState",
        "onPending",
        "onMined",
        "onFinalized",
        "onConfirmed",
        "prevState",
        "TransactionObject",
        "_transaction",
        "_nonceService",
        "_timeStampSubmitted",
        "Date",
        "_confirmedBlockCount",
        "confirmedBlockCount",
        "timeStampSubmitted",
        "timeStamp",
        "_timeStampMined",
        "fees",
        "_fees",
        "mine",
        "_dataPromise",
        "_getTransactionData",
        "_blockNumberWhenMined",
        "confirm",
        "count",
        "newBlockNumber",
        "waitForBlockNumber",
        "getTransactionReceipt",
        "hash",
        "blockHash",
        "_keepWaitingForTx",
        "gasPrice",
        "_waitForReceipt",
        "gasUsed",
        "status",
        "revertMsg",
        "JSON",
        "stringify",
        "retries",
        "currentTry",
        "startTime",
        "getTransaction",
        "elapsed",
        "TransactionManager",
        "_newTxListeners",
        "_tracker",
        "Tracker",
        "inspect",
        "_createTransactionObject",
        "_buildTransactionOptions",
        "_execute",
        "txOptions",
        "onNewTransaction",
        "onTransactionUpdate",
        "_globalListeners",
        "splice",
        "txs",
        "getAll",
        "listen",
        "handlers",
        "confirmed",
        "minePromise",
        "globalTxStateUpdates",
        "_getGasLimit",
        "transactionSettings",
        "_listeners",
        "_transactions",
        "_init",
        "clearExpiredTransactions",
        "warn",
        "each",
        "txList",
        "txAge",
        "getTime",
        "indexToRemove",
        "_this7",
        "l",
        "_list",
        "disconnectAll",
        "s",
        "manager",
        "_disconnect",
        "Web3Service",
        "_blockListeners",
        "_info",
        "Web3ServiceList",
        "_ethersSigner",
        "web3Provider",
        "getAddress",
        "isSigner",
        "_isSigner",
        "_transactionSettings",
        "Web3",
        "setProvider",
        "onDisconnected",
        "_stopListeningForNewBlocks",
        "_pollingInterval",
        "wait",
        "getAccounts",
        "getPastLogs",
        "getStorageAt",
        "net",
        "getId",
        "_networkId",
        "getBlockNumber",
        "_currentBlock",
        "_updateBlockNumber",
        "_listenForNewBlocks",
        "_newBlocksSubscription",
        "_updateBlocksInterval",
        "c",
        "n",
        "getNetworkName",
        "_providers",
        "_url",
        "mergeServiceConfig",
        "role",
        "sink",
        "source",
        "resolver",
        "standardizeConfig",
        "merge",
        "getSettings",
        "defaults",
        "cache",
        "gas",
        "smartContract",
        "disabled",
        "DefaultServiceProvider",
        "_ServiceProvider",
        "services",
        "ServiceProvider",
        "ConfigPresetNotFoundError",
        "message",
        "_Error",
        "serviceRoles",
        "reservedWords",
        "PLUGIN_KEYS",
        "MakerClass",
        "preset",
        "userOptions",
        "plugins",
        "otherOptions",
        "plugin",
        "addConfig",
        "mergeOptions",
        "test",
        "http",
        "ws",
        "loadPreset",
        "additionalServices",
        "words",
        "usedReservedWords",
        "intersection",
        "checkForReservedWords",
        "web3Settings",
        "ConfigFactory",
        "_container",
        "buildContainer",
        "afterCreate",
        "autoAuthenticate",
        "_authenticatedPromise",
        "openCdp",
        "getCdp",
        "getCdpIds",
        "skipAuthCheck",
        "isAuthenticated",
        "mergeWith",
        "objValue",
        "srcValue",
        "uniq",
        "standardizePluginConfig",
        "x",
        "pluginOptions",
        "some",
        "cloneDeep",
        "popts",
        "p",
        "beforeCreate",
        "maker",
        "Maker",
        "QueryApi",
        "stringToBytes32",
        "text",
        "pad",
        "ethersUtils",
        "toUtf8Bytes",
        "hexlify",
        "zeroPad",
        "padRight",
        "string",
        "chars",
        "sign",
        "getQueryResponse",
        "serverUrl",
        "query",
        "variables",
        "headers",
        "Accept",
        "body",
        "resp",
        "numberToBytes32",
        "num",
        "bn",
        "EthersBigNumber",
        "bytes32ToNumber",
        "bytes32",
        "toNumber",
        "stringToBytes",
        "str",
        "bytesToString",
        "hex",
        "toHex",
        "with0x",
        "rightPadding",
        "charCodeAt"
    ],
    "mappings": "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"
}